import fs from 'fs-extra';
import path from 'path';

/**
 * File generation engine
 * Generates CSS, Tailwind, TypeScript, and other output formats from design tokens
 */
export class FileGenerator {
  constructor(options = {}) {
    this.options = options;
  }

  /**
   * Generate all configured output files
   */
  async generateAll(tokens, config) {
    const results = {};

    // Generate CSS custom properties
    if (config.output.css) {
      results.css = await this.generateCSS(tokens, config.output.css);
    }

    // Generate Tailwind config
    if (config.output.tailwind) {
      results.tailwind = await this.generateTailwindConfig(tokens, config.output.tailwind);
    }

    // Generate TypeScript definitions
    if (config.output.typescript) {
      results.typescript = await this.generateTypeScript(tokens, config.output.typescript);
    }

    // Generate SCSS variables
    if (config.output.scss) {
      results.scss = await this.generateSCSS(tokens, config.output.scss);
    }

    return results;
  }

  /**
   * Generate CSS custom properties file
   */
  async generateCSS(tokens, outputPath) {
    const css = this.generateCSSCustomProperties(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, css);
    
    console.log(`✅ Generated CSS: ${outputPath}`);
    return { path: outputPath, content: css };
  }

  /**
   * Generate CSS custom properties string
   */
  generateCSSCustomProperties(tokens) {
    const cssVars = [];
    
    // Header comment
    cssVars.push('/* Design Tokens - Auto-generated */');
    cssVars.push('/* Do not edit this file manually */');
    cssVars.push('');
    cssVars.push(':root {');

    // Colors
    if (tokens.colors) {
      cssVars.push('  /* Colors */');
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.entries(shades).forEach(([shade, value]) => {
            cssVars.push(`  --color-${category}-${shade}: ${value};`);
          });
        }
      });
      cssVars.push('');
    }

    // Spacing
    if (tokens.spacing) {
      cssVars.push('  /* Spacing */');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        cssVars.push(`  --spacing-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Border Radius
    if (tokens.borderRadius) {
      cssVars.push('  /* Border Radius */');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        cssVars.push(`  --border-radius-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Typography
    if (tokens.typography) {
      cssVars.push('  /* Typography */');
      Object.entries(tokens.typography).forEach(([category, values]) => {
        if (values && typeof values === 'object') {
          Object.entries(values).forEach(([key, value]) => {
            cssVars.push(`  --typography-${category}-${key}: ${value};`);
          });
        }
      });
      cssVars.push('');
    }

    // Shadows
    if (tokens.shadows) {
      cssVars.push('  /* Shadows */');
      Object.entries(tokens.shadows).forEach(([key, value]) => {
        cssVars.push(`  --shadow-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Opacity
    if (tokens.opacity) {
      cssVars.push('  /* Opacity */');
      Object.entries(tokens.opacity).forEach(([key, value]) => {
        cssVars.push(`  --opacity-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Z-Index
    if (tokens.zIndex) {
      cssVars.push('  /* Z-Index */');
      Object.entries(tokens.zIndex).forEach(([key, value]) => {
        cssVars.push(`  --z-index-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Transitions
    if (tokens.transitions) {
      cssVars.push('  /* Transitions */');
      if (tokens.transitions.duration) {
        Object.entries(tokens.transitions.duration).forEach(([key, value]) => {
          cssVars.push(`  --transition-duration-${key}: ${value};`);
        });
      }
      if (tokens.transitions.easing) {
        Object.entries(tokens.transitions.easing).forEach(([key, value]) => {
          cssVars.push(`  --transition-easing-${key}: ${value};`);
        });
      }
      cssVars.push('');
    }

    // Breakpoints
    if (tokens.breakpoints) {
      cssVars.push('  /* Breakpoints */');
      Object.entries(tokens.breakpoints).forEach(([key, value]) => {
        cssVars.push(`  --breakpoint-${key}: ${value};`);
      });
      cssVars.push('');
    }

    cssVars.push('}');
    cssVars.push('');

    // Add utility classes
    cssVars.push('/* Utility Classes */');
    
    // Text colors
    if (tokens.colors) {
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.keys(shades).forEach(shade => {
            cssVars.push(`.text-${category}-${shade} { color: var(--color-${category}-${shade}); }`);
          });
        }
      });
    }

    return cssVars.join('\n');
  }

  /**
   * Generate Tailwind configuration
   */
  async generateTailwindConfig(tokens, outputPath) {
    const configContent = this.generateTailwindConfigContent(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, configContent);
    
    console.log(`✅ Generated Tailwind config: ${outputPath}`);
    return { path: outputPath, content: configContent };
  }

  /**
   * Generate Tailwind configuration content
   */
  generateTailwindConfigContent(tokens) {
    const config = {
      theme: {
        extend: {}
      }
    };

    // Colors
    if (tokens.colors && Object.keys(tokens.colors).length > 0) {
      config.theme.extend.colors = tokens.colors;
    }

    // Spacing
    if (tokens.spacing && Object.keys(tokens.spacing).length > 0) {
      config.theme.extend.spacing = tokens.spacing;
    }

    // Border Radius
    if (tokens.borderRadius && Object.keys(tokens.borderRadius).length > 0) {
      config.theme.extend.borderRadius = tokens.borderRadius;
    }

    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontFamily && Object.keys(tokens.typography.fontFamily).length > 0) {
        config.theme.extend.fontFamily = tokens.typography.fontFamily;
      }
      if (tokens.typography.fontSize && Object.keys(tokens.typography.fontSize).length > 0) {
        config.theme.extend.fontSize = tokens.typography.fontSize;
      }
      if (tokens.typography.fontWeight && Object.keys(tokens.typography.fontWeight).length > 0) {
        config.theme.extend.fontWeight = tokens.typography.fontWeight;
      }
      if (tokens.typography.lineHeight && Object.keys(tokens.typography.lineHeight).length > 0) {
        config.theme.extend.lineHeight = tokens.typography.lineHeight;
      }
      if (tokens.typography.letterSpacing && Object.keys(tokens.typography.letterSpacing).length > 0) {
        config.theme.extend.letterSpacing = tokens.typography.letterSpacing;
      }
    }

    // Shadows
    if (tokens.shadows && Object.keys(tokens.shadows).length > 0) {
      config.theme.extend.boxShadow = tokens.shadows;
    }

    // Opacity
    if (tokens.opacity && Object.keys(tokens.opacity).length > 0) {
      config.theme.extend.opacity = tokens.opacity;
    }

    // Z-Index
    if (tokens.zIndex && Object.keys(tokens.zIndex).length > 0) {
      config.theme.extend.zIndex = tokens.zIndex;
    }

    // Transitions
    if (tokens.transitions) {
      if (tokens.transitions.duration && Object.keys(tokens.transitions.duration).length > 0) {
        config.theme.extend.transitionDuration = tokens.transitions.duration;
      }
      if (tokens.transitions.easing && Object.keys(tokens.transitions.easing).length > 0) {
        config.theme.extend.transitionTimingFunction = tokens.transitions.easing;
      }
    }

    // Breakpoints
    if (tokens.breakpoints && Object.keys(tokens.breakpoints).length > 0) {
      config.theme.extend.screens = tokens.breakpoints;
    }

    const configString = `/** @type {import('tailwindcss').Config} */
// Design Tokens - Auto-generated Tailwind Configuration
// Do not edit this file manually

export default ${JSON.stringify(config, null, 2)};
`;

    return configString;
  }

  /**
   * Generate TypeScript definitions
   */
  async generateTypeScript(tokens, outputPath) {
    const typeDefinitions = this.generateTypeDefinitions(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, typeDefinitions);
    
    console.log(`✅ Generated TypeScript definitions: ${outputPath}`);
    return { path: outputPath, content: typeDefinitions };
  }

  /**
   * Generate TypeScript type definitions
   */
  generateTypeDefinitions(tokens) {
    const types = [];
    
    types.push('// Design Tokens - Auto-generated TypeScript Definitions');
    types.push('// Do not edit this file manually');
    types.push('');

    // Generate interfaces for each token category
    if (tokens.colors) {
      types.push('export interface Colors {');
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          types.push(`  ${category}: {`);
          Object.keys(shades).forEach(shade => {
            types.push(`    "${shade}": string;`);
          });
          types.push('  };');
        }
      });
      types.push('}');
      types.push('');
    }

    if (tokens.spacing) {
      types.push('export interface Spacing {');
      Object.keys(tokens.spacing).forEach(key => {
        types.push(`  "${key}": string;`);
      });
      types.push('}');
      types.push('');
    }

    if (tokens.typography) {
      types.push('export interface Typography {');
      Object.entries(tokens.typography).forEach(([category, values]) => {
        if (values && typeof values === 'object') {
          types.push(`  ${category}: {`);
          Object.keys(values).forEach(key => {
            types.push(`    "${key}": string;`);
          });
          types.push('  };');
        }
      });
      types.push('}');
      types.push('');
    }

    // Main design tokens interface
    types.push('export interface DesignTokens {');
    if (tokens.colors) types.push('  colors: Colors;');
    if (tokens.spacing) types.push('  spacing: Spacing;');
    if (tokens.typography) types.push('  typography: Typography;');
    if (tokens.borderRadius) types.push('  borderRadius: Record<string, string>;');
    if (tokens.shadows) types.push('  shadows: Record<string, string>;');
    if (tokens.opacity) types.push('  opacity: Record<string, string>;');
    if (tokens.zIndex) types.push('  zIndex: Record<string, number>;');
    if (tokens.transitions) {
      types.push('  transitions: {');
      types.push('    duration: Record<string, string>;');
      types.push('    easing: Record<string, string>;');
      types.push('  };');
    }
    if (tokens.breakpoints) types.push('  breakpoints: Record<string, string>;');
    types.push('  source: string;');
    types.push('  lastLoaded: string;');
    types.push('}');
    types.push('');

    // Export token constants
    types.push('// Token value constants');
    types.push('declare const tokens: DesignTokens;');
    types.push('export default tokens;');

    return types.join('\n');
  }

  /**
   * Generate SCSS variables
   */
  async generateSCSS(tokens, outputPath) {
    const scss = this.generateSCSSVariables(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, scss);
    
    console.log(`✅ Generated SCSS: ${outputPath}`);
    return { path: outputPath, content: scss };
  }

  /**
   * Generate SCSS variables string
   */
  generateSCSSVariables(tokens) {
    const scss = [];
    
    scss.push('// Design Tokens - Auto-generated SCSS Variables');
    scss.push('// Do not edit this file manually');
    scss.push('');

    // Colors
    if (tokens.colors) {
      scss.push('// Colors');
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.entries(shades).forEach(([shade, value]) => {
            scss.push(`$color-${category}-${shade}: ${value};`);
          });
        }
      });
      scss.push('');
    }

    // Spacing
    if (tokens.spacing) {
      scss.push('// Spacing');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        scss.push(`$spacing-${key}: ${value};`);
      });
      scss.push('');
    }

    // Typography
    if (tokens.typography) {
      scss.push('// Typography');
      Object.entries(tokens.typography).forEach(([category, values]) => {
        if (values && typeof values === 'object') {
          Object.entries(values).forEach(([key, value]) => {
            scss.push(`$typography-${category}-${key}: ${value};`);
          });
        }
      });
      scss.push('');
    }

    // Other categories
    ['borderRadius', 'shadows', 'opacity', 'zIndex'].forEach(category => {
      if (tokens[category]) {
        scss.push(`// ${category.charAt(0).toUpperCase() + category.slice(1)}`);
        Object.entries(tokens[category]).forEach(([key, value]) => {
          const variableName = this.kebabCase(category);
          scss.push(`$${variableName}-${key}: ${value};`);
        });
        scss.push('');
      }
    });

    // Transitions
    if (tokens.transitions) {
      scss.push('// Transitions');
      if (tokens.transitions.duration) {
        Object.entries(tokens.transitions.duration).forEach(([key, value]) => {
          scss.push(`$transition-duration-${key}: ${value};`);
        });
      }
      if (tokens.transitions.easing) {
        Object.entries(tokens.transitions.easing).forEach(([key, value]) => {
          scss.push(`$transition-easing-${key}: ${value};`);
        });
      }
      scss.push('');
    }

    // Breakpoints
    if (tokens.breakpoints) {
      scss.push('// Breakpoints');
      Object.entries(tokens.breakpoints).forEach(([key, value]) => {
        scss.push(`$breakpoint-${key}: ${value};`);
      });
      scss.push('');
    }

    return scss.join('\n');
  }

  /**
   * Generate platform-specific formats
   */
  async generateIOS(tokens, outputPath) {
    // iOS color definitions
    const swift = this.generateSwiftColors(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, swift);
    
    console.log(`✅ Generated iOS Swift: ${outputPath}`);
    return { path: outputPath, content: swift };
  }

  async generateAndroid(tokens, outputPath) {
    // Android XML resources
    const xml = this.generateAndroidXML(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, xml);
    
    console.log(`✅ Generated Android XML: ${outputPath}`);
    return { path: outputPath, content: xml };
  }

  /**
   * Utility methods
   */
  kebabCase(str) {
    return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
  }

  generateSwiftColors(tokens) {
    const swift = [];
    swift.push('// Design Tokens - Auto-generated Swift Colors');
    swift.push('import UIKit');
    swift.push('');
    swift.push('extension UIColor {');
    
    if (tokens.colors) {
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.entries(shades).forEach(([shade, value]) => {
            if (value.startsWith('#')) {
              swift.push(`    static let ${category}${shade.charAt(0).toUpperCase() + shade.slice(1)} = UIColor(hex: "${value}")`);
            }
          });
        }
      });
    }
    
    swift.push('}');
    return swift.join('\n');
  }

  generateAndroidXML(tokens) {
    const xml = [];
    xml.push('<?xml version="1.0" encoding="utf-8"?>');
    xml.push('<!-- Design Tokens - Auto-generated Android Colors -->');
    xml.push('<resources>');
    
    if (tokens.colors) {
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.entries(shades).forEach(([shade, value]) => {
            if (value.startsWith('#')) {
              xml.push(`    <color name="${category}_${shade}">${value}</color>`);
            }
          });
        }
      });
    }
    
    xml.push('</resources>');
    return xml.join('\n');
  }
} 