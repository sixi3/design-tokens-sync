import fs from 'fs-extra';
import path from 'path';

/**
 * File generation engine
 * Generates CSS, Tailwind, TypeScript, and other output formats from design tokens
 */
export class FileGenerator {
  constructor(options = {}) {
    this.options = options;
  }

  /**
   * Generate all configured output files
   */
  async generateAll(tokens, config) {
    const results = {};

    // Generate CSS custom properties
    if (config.output.css) {
      const includeUtilities = !!(config.css && config.css.includeUtilities);
      results.css = await this.generateCSS(tokens, config.output.css, { includeUtilities });
    }

    // Generate Tailwind config (deprecated path)
    if (config.output.tailwind) {
      console.warn('⚠️  Deprecation: Generating a root Tailwind config. Prefer presets via output.tailwindPresetEsm/Cjs.');
      results.tailwind = await this.generateTailwindConfig(tokens, config.output.tailwind);
    }

    // Generate Tailwind presets (preferred)
    if (config.output.tailwindPresetEsm) {
      results.tailwindPresetEsm = await this.generateTailwindPreset(tokens, config.output.tailwindPresetEsm, 'esm');
    }
    if (config.output.tailwindPresetCjs) {
      results.tailwindPresetCjs = await this.generateTailwindPreset(tokens, config.output.tailwindPresetCjs, 'cjs');
    }

    // Generate TypeScript definitions
    if (config.output.typescript) {
      results.typescript = await this.generateTypeScript(tokens, config.output.typescript);
    }

    // Generate SCSS variables
    if (config.output.scss) {
      results.scss = await this.generateSCSS(tokens, config.output.scss);
    }

    // Generate iOS Swift
    if (config.output.ios) {
      results.ios = await this.generateIOS(tokens, config.output.ios);
    }

    // Generate Android XML
    if (config.output.android) {
      results.android = await this.generateAndroid(tokens, config.output.android);
    }

    // Generate Xamarin (if implemented)
    if (config.output.xamarin) {
      results.xamarin = await this.generateXamarin(tokens, config.output.xamarin);
    }

    // Generate React Native
    if (config.output.reactNative) {
      results.reactNative = await this.generateReactNative(tokens, config.output.reactNative);
    }

    // Generate Flutter/Dart
    if (config.output.flutter) {
      results.flutter = await this.generateFlutter(tokens, config.output.flutter);
    }

    // Generate Kotlin Compose
    if (config.output.kotlinCompose) {
      results.kotlinCompose = await this.generateKotlinCompose(tokens, config.output.kotlinCompose);
    }

    // Generate SwiftUI
    if (config.output.swiftui) {
      results.swiftui = await this.generateSwiftUI(tokens, config.output.swiftui);
    }

    // Generate JSON output
    if (config.output.json) {
      results.json = await this.generateJSON(tokens, config.output.json);
    }

    // Generate JavaScript output
    if (config.output.javascript) {
      results.javascript = await this.generateJavaScript(tokens, config.output.javascript);
    }

    // Generate CommonJS tokens output
    if (config.output.tokensCjs) {
      results.tokensCjs = await this.generateTokensCjs(tokens, config.output.tokensCjs);
    }

    // Generate shadcn theme CSS bridge
    if (config.shadcn && config.shadcn.enable && config.output.shadcnThemeCss) {
      results.shadcnThemeCss = await this.generateShadcnThemeCss(tokens, config.output.shadcnThemeCss, {
        hsl: config.shadcn.hsl !== false,
        format: config.shadcn.format || 'hsl',
        mapping: config.shadcn.mapping || {},
        strict: !!config.shadcn.strict,
        fallback: config.shadcn.fallback || 'shadcn',
        extend: config.shadcn.extend || {}
      });
    }

    return results;
  }

  /**
   * Generate CSS custom properties file
   */
  async generateCSS(tokens, outputPath, options = {}) {
    const css = this.generateCSSCustomProperties(tokens, options);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, css);
    
    console.log(`✅ Generated CSS: ${outputPath}`);
    return { path: outputPath, content: css };
  }

  /**
   * Generate CSS custom properties string
   */
  generateCSSCustomProperties(tokens, options = {}) {
    const cssVars = [];
    
    // Header comment
    cssVars.push('/* Design Tokens - Auto-generated */');
    cssVars.push('/* Do not edit this file manually */');
    cssVars.push('');
    cssVars.push(':root {');

    // Colors
    if (tokens.colors) {
      cssVars.push('  /* Colors */');
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.entries(shades).forEach(([shade, value]) => {
            const actualValue = this.getTokenValue(value);
            cssVars.push(`  --color-${category}-${shade}: ${actualValue};`);
          });
        }
      });
      cssVars.push('');
    }

    // Spacing
    if (tokens.spacing) {
      cssVars.push('  /* Spacing */');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        cssVars.push(`  --spacing-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Border Radius
    if (tokens.borderRadius) {
      cssVars.push('  /* Border Radius */');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        cssVars.push(`  --border-radius-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Typography
    if (tokens.typography) {
      cssVars.push('  /* Typography */');
      Object.entries(tokens.typography).forEach(([category, values]) => {
        if (values && typeof values === 'object') {
          Object.entries(values).forEach(([key, value]) => {
            cssVars.push(`  --typography-${category}-${key}: ${value};`);
          });
        }
      });
      cssVars.push('');
    }

    // Shadows
    if (tokens.shadows) {
      cssVars.push('  /* Shadows */');
      Object.entries(tokens.shadows).forEach(([key, value]) => {
        cssVars.push(`  --shadow-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Opacity
    if (tokens.opacity) {
      cssVars.push('  /* Opacity */');
      Object.entries(tokens.opacity).forEach(([key, value]) => {
        cssVars.push(`  --opacity-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Z-Index
    if (tokens.zIndex) {
      cssVars.push('  /* Z-Index */');
      Object.entries(tokens.zIndex).forEach(([key, value]) => {
        cssVars.push(`  --z-index-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Transitions
    if (tokens.transitions) {
      cssVars.push('  /* Transitions */');
      if (tokens.transitions.duration) {
        Object.entries(tokens.transitions.duration).forEach(([key, value]) => {
          cssVars.push(`  --transition-duration-${key}: ${value};`);
        });
      }
      if (tokens.transitions.easing) {
        Object.entries(tokens.transitions.easing).forEach(([key, value]) => {
          cssVars.push(`  --transition-easing-${key}: ${value};`);
        });
      }
      cssVars.push('');
    }

    // Breakpoints
    if (tokens.breakpoints) {
      cssVars.push('  /* Breakpoints */');
      Object.entries(tokens.breakpoints).forEach(([key, value]) => {
        cssVars.push(`  --breakpoint-${key}: ${value};`);
      });
      cssVars.push('');
    }

    cssVars.push('}');
    cssVars.push('');

    if (options.includeUtilities) {
      cssVars.push('/* Utility Classes */');
      if (tokens.colors) {
        Object.entries(tokens.colors).forEach(([category, shades]) => {
          if (shades && typeof shades === 'object') {
            Object.keys(shades).forEach(shade => {
              cssVars.push(`.text-${category}-${shade} { color: var(--color-${category}-${shade}); }`);
            });
          }
        });
      }
    }

    return cssVars.join('\n');
  }

  /**
   * Generate Tailwind configuration
   */
  async generateTailwindConfig(tokens, outputPath) {
    const configContent = this.generateTailwindConfigContent(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, configContent);
    
    console.log(`✅ Generated Tailwind config: ${outputPath}`);
    return { path: outputPath, content: configContent };
  }

  /**
   * Generate Tailwind preset (ESM or CJS)
   */
  async generateTailwindPreset(tokens, outputPath, format = 'esm') {
    const presetObject = this.generateTailwindPresetObject(tokens);
    const content = format === 'cjs'
      ? `/** @type {import('tailwindcss').Config} */
// Design Tokens - Auto-generated Tailwind Preset (CJS)
// Do not edit this file manually

module.exports = ${JSON.stringify(presetObject, null, 2)};
`
      : `/** @type {import('tailwindcss').Config} */
// Design Tokens - Auto-generated Tailwind Preset (ESM)
// Do not edit this file manually

export default ${JSON.stringify(presetObject, null, 2)};
`;
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    console.log(`✅ Generated Tailwind preset: ${outputPath}`);
    return { path: outputPath, content };
  }

  /**
   * Preset object builder: { theme: { extend: ... } }
   */
  generateTailwindPresetObject(tokens) {
    const extend = {};
    if (tokens.colors && Object.keys(tokens.colors).length > 0) extend.colors = tokens.colors;
    if (tokens.spacing && Object.keys(tokens.spacing).length > 0) extend.spacing = tokens.spacing;
    if (tokens.borderRadius && Object.keys(tokens.borderRadius).length > 0) extend.borderRadius = tokens.borderRadius;
    if (tokens.typography) {
      if (tokens.typography.fontFamily && Object.keys(tokens.typography.fontFamily).length > 0) extend.fontFamily = tokens.typography.fontFamily;
      if (tokens.typography.fontSize && Object.keys(tokens.typography.fontSize).length > 0) extend.fontSize = tokens.typography.fontSize;
      if (tokens.typography.fontWeight && Object.keys(tokens.typography.fontWeight).length > 0) extend.fontWeight = tokens.typography.fontWeight;
      if (tokens.typography.lineHeight && Object.keys(tokens.typography.lineHeight).length > 0) extend.lineHeight = tokens.typography.lineHeight;
      if (tokens.typography.letterSpacing && Object.keys(tokens.typography.letterSpacing).length > 0) extend.letterSpacing = tokens.typography.letterSpacing;
    }
    if (tokens.shadows && Object.keys(tokens.shadows).length > 0) extend.boxShadow = tokens.shadows;
    if (tokens.opacity && Object.keys(tokens.opacity).length > 0) extend.opacity = tokens.opacity;
    if (tokens.zIndex && Object.keys(tokens.zIndex).length > 0) extend.zIndex = tokens.zIndex;
    if (tokens.transitions) {
      if (tokens.transitions.duration && Object.keys(tokens.transitions.duration).length > 0) extend.transitionDuration = tokens.transitions.duration;
      if (tokens.transitions.easing && Object.keys(tokens.transitions.easing).length > 0) extend.transitionTimingFunction = tokens.transitions.easing;
    }
    if (tokens.breakpoints && Object.keys(tokens.breakpoints).length > 0) extend.screens = tokens.breakpoints;
    return { theme: { extend } };
  }

  /**
   * Generate Tailwind configuration content
   */
  generateTailwindConfigContent(tokens) {
    const config = {
      theme: {
        extend: {}
      }
    };

    // Colors
    if (tokens.colors && Object.keys(tokens.colors).length > 0) {
      config.theme.extend.colors = tokens.colors;
    }

    // Spacing
    if (tokens.spacing && Object.keys(tokens.spacing).length > 0) {
      config.theme.extend.spacing = tokens.spacing;
    }

    // Border Radius
    if (tokens.borderRadius && Object.keys(tokens.borderRadius).length > 0) {
      config.theme.extend.borderRadius = tokens.borderRadius;
    }

    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontFamily && Object.keys(tokens.typography.fontFamily).length > 0) {
        config.theme.extend.fontFamily = tokens.typography.fontFamily;
      }
      if (tokens.typography.fontSize && Object.keys(tokens.typography.fontSize).length > 0) {
        config.theme.extend.fontSize = tokens.typography.fontSize;
      }
      if (tokens.typography.fontWeight && Object.keys(tokens.typography.fontWeight).length > 0) {
        config.theme.extend.fontWeight = tokens.typography.fontWeight;
      }
      if (tokens.typography.lineHeight && Object.keys(tokens.typography.lineHeight).length > 0) {
        config.theme.extend.lineHeight = tokens.typography.lineHeight;
      }
      if (tokens.typography.letterSpacing && Object.keys(tokens.typography.letterSpacing).length > 0) {
        config.theme.extend.letterSpacing = tokens.typography.letterSpacing;
      }
    }

    // Shadows
    if (tokens.shadows && Object.keys(tokens.shadows).length > 0) {
      config.theme.extend.boxShadow = tokens.shadows;
    }

    // Opacity
    if (tokens.opacity && Object.keys(tokens.opacity).length > 0) {
      config.theme.extend.opacity = tokens.opacity;
    }

    // Z-Index
    if (tokens.zIndex && Object.keys(tokens.zIndex).length > 0) {
      config.theme.extend.zIndex = tokens.zIndex;
    }

    // Transitions
    if (tokens.transitions) {
      if (tokens.transitions.duration && Object.keys(tokens.transitions.duration).length > 0) {
        config.theme.extend.transitionDuration = tokens.transitions.duration;
      }
      if (tokens.transitions.easing && Object.keys(tokens.transitions.easing).length > 0) {
        config.theme.extend.transitionTimingFunction = tokens.transitions.easing;
      }
    }

    // Breakpoints
    if (tokens.breakpoints && Object.keys(tokens.breakpoints).length > 0) {
      config.theme.extend.screens = tokens.breakpoints;
    }

    const configString = `/** @type {import('tailwindcss').Config} */
// Design Tokens - Auto-generated Tailwind Configuration
// Do not edit this file manually

export default ${JSON.stringify(config, null, 2)};
`;

    return configString;
  }

  /**
   * Generate TypeScript definitions
   */
  async generateTypeScript(tokens, outputPath) {
    const typeDefinitions = this.generateTypeDefinitions(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, typeDefinitions);
    
    console.log(`✅ Generated TypeScript definitions: ${outputPath}`);
    return { path: outputPath, content: typeDefinitions };
  }

  /**
   * Generate TypeScript type definitions
   */
  generateTypeDefinitions(tokens) {
    const types = [];
    
    types.push('// Design Tokens - Auto-generated TypeScript Definitions');
    types.push('// Do not edit this file manually');
    types.push('');

    // Generate interfaces for each token category
    if (tokens.colors) {
      types.push('export interface Colors {');
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          types.push(`  ${category}: {`);
          Object.keys(shades).forEach(shade => {
            types.push(`    "${shade}": string;`);
          });
          types.push('  };');
        }
      });
      types.push('}');
      types.push('');
    }

    if (tokens.spacing) {
      types.push('export interface Spacing {');
      Object.keys(tokens.spacing).forEach(key => {
        types.push(`  "${key}": string;`);
      });
      types.push('}');
      types.push('');
    }

    if (tokens.typography) {
      types.push('export interface Typography {');
      Object.entries(tokens.typography).forEach(([category, values]) => {
        if (values && typeof values === 'object') {
          types.push(`  ${category}: {`);
          Object.keys(values).forEach(key => {
            types.push(`    "${key}": string;`);
          });
          types.push('  };');
        }
      });
      types.push('}');
      types.push('');
    }

    // Main design tokens interface
    types.push('export interface DesignTokens {');
    if (tokens.colors) types.push('  colors: Colors;');
    if (tokens.spacing) types.push('  spacing: Spacing;');
    if (tokens.typography) types.push('  typography: Typography;');
    if (tokens.borderRadius) types.push('  borderRadius: Record<string, string>;');
    if (tokens.shadows) types.push('  shadows: Record<string, string>;');
    if (tokens.opacity) types.push('  opacity: Record<string, string>;');
    if (tokens.zIndex) types.push('  zIndex: Record<string, number>;');
    if (tokens.transitions) {
      types.push('  transitions: {');
      types.push('    duration: Record<string, string>;');
      types.push('    easing: Record<string, string>;');
      types.push('  };');
    }
    if (tokens.breakpoints) types.push('  breakpoints: Record<string, string>;');
    types.push('  source?: string;');
    types.push('  lastLoaded?: string;');
    types.push('}');
    types.push('');

    // Export token constants
    types.push('// Token value constants');
    types.push('declare const tokens: DesignTokens;');
    types.push('export default tokens;');

    // Named exports (align with JS emitter)
    if (tokens.colors) types.push('export const colors: Colors;');
    if (tokens.spacing) types.push('export const spacing: Spacing;');
    if (tokens.typography) types.push('export const typography: Typography;');
    if (tokens.borderRadius) types.push('export const borderRadius: Record<string, string>;');
    if (tokens.shadows) types.push('export const shadows: Record<string, string>;');
    if (tokens.opacity) types.push('export const opacity: Record<string, string>;');

    return types.join('\n');
  }

  /**
   * Generate SCSS variables
   */
  async generateSCSS(tokens, outputPath) {
    const scss = this.generateSCSSVariables(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, scss);
    
    console.log(`✅ Generated SCSS: ${outputPath}`);
    return { path: outputPath, content: scss };
  }

  /**
   * Generate SCSS variables string
   */
  generateSCSSVariables(tokens) {
    const scss = [];
    
    scss.push('// Design Tokens - Auto-generated SCSS Variables');
    scss.push('// Do not edit this file manually');
    scss.push('');

    // Colors
    if (tokens.colors) {
      scss.push('// Colors');
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.entries(shades).forEach(([shade, value]) => {
            const actualValue = this.getTokenValue(value);
            scss.push(`$color-${category}-${shade}: ${actualValue};`);
          });
        }
      });
      scss.push('');
    }

    // Spacing
    if (tokens.spacing) {
      scss.push('// Spacing');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        scss.push(`$spacing-${key}: ${value};`);
      });
      scss.push('');
    }

    // Typography
    if (tokens.typography) {
      scss.push('// Typography');
      Object.entries(tokens.typography).forEach(([category, values]) => {
        if (values && typeof values === 'object') {
          Object.entries(values).forEach(([key, value]) => {
            scss.push(`$typography-${category}-${key}: ${value};`);
          });
        }
      });
      scss.push('');
    }

    // Other categories
    ['borderRadius', 'shadows', 'opacity', 'zIndex'].forEach(category => {
      if (tokens[category]) {
        scss.push(`// ${category.charAt(0).toUpperCase() + category.slice(1)}`);
        Object.entries(tokens[category]).forEach(([key, value]) => {
          const variableName = this.kebabCase(category);
          scss.push(`$${variableName}-${key}: ${value};`);
        });
        scss.push('');
      }
    });

    // Transitions
    if (tokens.transitions) {
      scss.push('// Transitions');
      if (tokens.transitions.duration) {
        Object.entries(tokens.transitions.duration).forEach(([key, value]) => {
          scss.push(`$transition-duration-${key}: ${value};`);
        });
      }
      if (tokens.transitions.easing) {
        Object.entries(tokens.transitions.easing).forEach(([key, value]) => {
          scss.push(`$transition-easing-${key}: ${value};`);
        });
      }
      scss.push('');
    }

    // Breakpoints
    if (tokens.breakpoints) {
      scss.push('// Breakpoints');
      Object.entries(tokens.breakpoints).forEach(([key, value]) => {
        scss.push(`$breakpoint-${key}: ${value};`);
      });
      scss.push('');
    }

    return scss.join('\n');
  }

  /**
   * Generate platform-specific formats
   */
  async generateIOS(tokens, outputPath) {
    // iOS color definitions
    const swift = this.generateSwiftColors(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, swift);
    
    console.log(`✅ Generated iOS Swift: ${outputPath}`);
    return { path: outputPath, content: swift };
  }

  async generateAndroid(tokens, outputPath) {
    // Android XML resources
    const xml = this.generateAndroidXML(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, xml);
    
    console.log(`✅ Generated Android XML: ${outputPath}`);
    return { path: outputPath, content: xml };
  }

  async generateXamarin(tokens, outputPath) {
    // Xamarin XAML resource dictionary
    const xaml = this.generateXamarinXAML(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, xaml);
    
    console.log(`✅ Generated Xamarin XAML: ${outputPath}`);
    return { path: outputPath, content: xaml };
  }

  async generateReactNative(tokens, outputPath) {
    // React Native compatible JavaScript/TypeScript
    const content = this.generateReactNativeContent(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    
    console.log(`✅ Generated React Native: ${outputPath}`);
    return { path: outputPath, content };
  }

  async generateFlutter(tokens, outputPath) {
    // Flutter/Dart class
    const content = this.generateFlutterContent(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    
    console.log(`✅ Generated Flutter/Dart: ${outputPath}`);
    return { path: outputPath, content };
  }

  async generateKotlinCompose(tokens, outputPath) {
    // Kotlin Compose class
    const content = this.generateKotlinComposeContent(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    
    console.log(`✅ Generated Kotlin Compose: ${outputPath}`);
    return { path: outputPath, content };
  }

  async generateSwiftUI(tokens, outputPath) {
    // SwiftUI class
    const content = this.generateSwiftUIContent(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    
    console.log(`✅ Generated SwiftUI: ${outputPath}`);
    return { path: outputPath, content };
  }

  /**
   * Utility methods
   */
  
  /**
   * Get token value from either Token Studio format or direct value
   */
  getTokenValue(tokenData) {
    if (tokenData && typeof tokenData === 'object') {
      // Token Studio format: {value: "...", type: "..."}
      return tokenData.value || tokenData.$value;
    }
    // Direct value
    return tokenData;
  }

  kebabCase(str) {
    return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
  }

  toCamelCase(str) {
    const result = str
      .replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
      .replace(/^./, c => c.toLowerCase());
    
    // If the result starts with a number, prefix with underscore to make it a valid JS identifier
    if (/^\d/.test(result)) {
      return `_${result}`;
    }
    
    return result;
  }

  toPascalCase(str) {
    return str
      .replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
      .replace(/^./, c => c.toUpperCase());
  }

  convertToPoints(cssValue) {
    if (typeof cssValue !== 'string') return '0';
    
    // Remove any whitespace
    const value = cssValue.trim();
    
    // Handle numeric values (assume px)
    if (/^\d+\.?\d*$/.test(value)) {
      return value;
    }
    
    // Convert common CSS units to points
    const match = value.match(/^([\d.]+)(px|rem|em|pt)$/);
    if (match) {
      const [, num, unit] = match;
      const numValue = parseFloat(num);
      
      switch (unit) {
        case 'px':
          return numValue.toString();
        case 'rem':
          return (numValue * 16).toString(); // Assuming 1rem = 16px
        case 'em':
          return (numValue * 16).toString(); // Assuming 1em = 16px
        case 'pt':
          return numValue.toString();
        default:
          return numValue.toString();
      }
    }
    
    return '0';
  }

  parseCSShadow(shadowValue) {
    // Parse CSS box-shadow value
    // Format: offset-x offset-y blur-radius color
    // Example: "0 2px 4px rgba(0, 0, 0, 0.1)"
    const parts = shadowValue.trim().split(/\s+/);
    
    let x = '0', y = '0', blur = '0', color = '#000000';
    
    if (parts.length >= 2) {
      x = this.convertToPoints(parts[0]);
      y = this.convertToPoints(parts[1]);
    }
    
    if (parts.length >= 3) {
      blur = this.convertToPoints(parts[2]);
    }
    
    if (parts.length >= 4) {
      // Find color part (might have spaces for rgba)
      const colorPart = parts.slice(3).join(' ');
      if (colorPart.startsWith('#')) {
        color = colorPart;
      } else if (colorPart.includes('rgba')) {
        // Convert rgba to hex (simplified)
        color = '#000000'; // Fallback
      }
    }
    
    return { x, y, blur, color };
  }

  convertToDp(cssValue) {
    if (typeof cssValue !== 'string') return '0dp';
    
    const value = cssValue.trim();
    
    // Handle numeric values (assume px)
    if (/^\d+\.?\d*$/.test(value)) {
      return `${value}dp`;
    }
    
    // Convert common CSS units to dp
    const match = value.match(/^([\d.]+)(px|rem|em|dp)$/);
    if (match) {
      const [, num, unit] = match;
      const numValue = parseFloat(num);
      
      switch (unit) {
        case 'px':
          return `${numValue}dp`;
        case 'rem':
          return `${numValue * 16}dp`; // Assuming 1rem = 16px
        case 'em':
          return `${numValue * 16}dp`; // Assuming 1em = 16px
        case 'dp':
          return `${numValue}dp`;
        default:
          return `${numValue}dp`;
      }
    }
    
    return '0dp';
  }

  convertToSp(cssValue) {
    if (typeof cssValue !== 'string') return '0sp';
    
    const value = cssValue.trim();
    
    // Handle numeric values (assume px)
    if (/^\d+\.?\d*$/.test(value)) {
      return `${value}sp`;
    }
    
    // Convert common CSS units to sp (for text sizes)
    const match = value.match(/^([\d.]+)(px|rem|em|sp)$/);
    if (match) {
      const [, num, unit] = match;
      const numValue = parseFloat(num);
      
      switch (unit) {
        case 'px':
          return `${numValue}sp`;
        case 'rem':
          return `${numValue * 16}sp`; // Assuming 1rem = 16px
        case 'em':
          return `${numValue * 16}sp`; // Assuming 1em = 16px
        case 'sp':
          return `${numValue}sp`;
        default:
          return `${numValue}sp`;
      }
    }
    
    return '0sp';
  }

  convertToRNPoints(cssValue) {
    if (typeof cssValue !== 'string') return 0;
    
    const value = cssValue.trim();
    
    // Handle numeric values (assume px)
    if (/^\d+\.?\d*$/.test(value)) {
      return parseFloat(value);
    }
    
    // Convert common CSS units to React Native points
    const match = value.match(/^([\d.]+)(px|rem|em)$/);
    if (match) {
      const [, num, unit] = match;
      const numValue = parseFloat(num);
      
      switch (unit) {
        case 'px':
          return numValue;
        case 'rem':
          return numValue * 16; // Assuming 1rem = 16px
        case 'em':
          return numValue * 16; // Assuming 1em = 16px
        default:
          return numValue;
      }
    }
    
    return 0;
  }

  convertToRNShadow(cssValue) {
    // Convert CSS box-shadow to React Native shadow style
    const shadowProps = this.parseCSShadow(cssValue);
    
    return {
      shadowOffset: {
        width: parseFloat(shadowProps.x),
        height: parseFloat(shadowProps.y)
      },
      shadowRadius: parseFloat(shadowProps.blur),
      shadowColor: shadowProps.color,
      shadowOpacity: 1,
      // Also add elevation for Android
      elevation: Math.max(2, parseFloat(shadowProps.blur) / 2)
    };
  }

  convertToFlutterColor(hexColor) {
    // Convert hex color to Flutter Color format
    if (!hexColor.startsWith('#')) return 'Colors.black';
    
    const hex = hexColor.replace('#', '');
    if (hex.length === 6) {
      return `Color(0xFF${hex.toUpperCase()})`;
    } else if (hex.length === 3) {
      // Expand 3-digit hex to 6-digit
      const expanded = hex.split('').map(c => c + c).join('');
      return `Color(0xFF${expanded.toUpperCase()})`;
    }
    
    return 'Colors.black';
  }

  convertToComposeColor(hexColor) {
    // Convert hex color to Jetpack Compose Color format
    if (!hexColor.startsWith('#')) return 'Color.Black';
    
    const hex = hexColor.replace('#', '');
    if (hex.length === 6) {
      return `Color(0xFF${hex.toUpperCase()})`;
    } else if (hex.length === 3) {
      // Expand 3-digit hex to 6-digit
      const expanded = hex.split('').map(c => c + c).join('');
      return `Color(0xFF${expanded.toUpperCase()})`;
    }
    
    return 'Color.Black';
  }

  convertToSwiftUIColor(hexColor) {
    // Convert hex color to SwiftUI Color format
    if (!hexColor.startsWith('#')) return 'Color.black';
    
    const hex = hexColor.replace('#', '');
    let r, g, b;
    
    if (hex.length === 6) {
      r = parseInt(hex.substr(0, 2), 16) / 255;
      g = parseInt(hex.substr(2, 2), 16) / 255;
      b = parseInt(hex.substr(4, 2), 16) / 255;
    } else if (hex.length === 3) {
      r = parseInt(hex.substr(0, 1) + hex.substr(0, 1), 16) / 255;
      g = parseInt(hex.substr(1, 1) + hex.substr(1, 1), 16) / 255;
      b = parseInt(hex.substr(2, 1) + hex.substr(2, 1), 16) / 255;
    } else {
      return 'Color.black';
    }
    
    return `Color(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)})`;
  }

  generateSwiftColors(tokens) {
    const swift = [];
    swift.push('// Design Tokens - Auto-generated Swift');
    swift.push('// Do not edit this file manually');
    swift.push('import UIKit');
    swift.push('');
    
    // Colors
    if (tokens.colors) {
      swift.push('extension UIColor {');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          // Nested structure: category -> shade -> value
          Object.entries(value).forEach(([shade, colorValue]) => {
            // Handle both simple string values and Figma Token Studio format
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              const varName = this.toCamelCase(`${key} ${shade}`);
              swift.push(`    static let ${varName} = UIColor(hex: "${actualValue}")`);
            }
          });
        } else {
          // Handle flat structure
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const varName = this.toCamelCase(key);
            swift.push(`    static let ${varName} = UIColor(hex: "${actualValue}")`);
          }
        }
      });
      swift.push('}');
      swift.push('');
    }
    
    // Spacing
    if (tokens.spacing) {
      swift.push('struct Spacing {');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          swift.push(`    static let ${this.toCamelCase(key)}: CGFloat = ${numericValue}`);
        }
      });
      swift.push('}');
      swift.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        swift.push('struct FontSize {');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToPoints(actualValue);
            swift.push(`    static let ${this.toCamelCase(key)}: CGFloat = ${numericValue}`);
          }
        });
        swift.push('}');
        swift.push('');
      }
      
      if (tokens.typography.fontFamily) {
        swift.push('struct FontFamily {');
        Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            // Extract first font from font stack for iOS
            const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
            swift.push(`    static let ${this.toCamelCase(key)} = "${fontName}"`);
          }
        });
        swift.push('}');
        swift.push('');
      }
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      swift.push('struct BorderRadius {');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          swift.push(`    static let ${this.toCamelCase(key)}: CGFloat = ${numericValue}`);
        }
      });
      swift.push('}');
      swift.push('');
    }
    
    // Shadows
    if (tokens.shadows) {
      swift.push('struct Shadow {');
      Object.entries(tokens.shadows).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          // Parse CSS shadow into iOS shadow properties
          const shadowProps = this.parseCSShadow(actualValue);
          swift.push(`    static let ${this.toCamelCase(key)} = ShadowStyle(`);
          swift.push(`        offset: CGSize(width: ${shadowProps.x}, height: ${shadowProps.y}),`);
          swift.push(`        blur: ${shadowProps.blur},`);
          swift.push(`        color: UIColor(hex: "${shadowProps.color}")`);
          swift.push(`    )`);
        }
      });
      swift.push('}');
      swift.push('');
      
      // Add shadow style struct
      swift.push('struct ShadowStyle {');
      swift.push('    let offset: CGSize');
      swift.push('    let blur: CGFloat');
      swift.push('    let color: UIColor');
      swift.push('}');
      swift.push('');
    }
    
    swift.push('// UIColor hex initializer extension');
    swift.push('extension UIColor {');
    swift.push('    convenience init(hex: String) {');
    swift.push('        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)');
    swift.push('        var int: UInt64 = 0');
    swift.push('        Scanner(string: hex).scanHexInt64(&int)');
    swift.push('        let a, r, g, b: UInt64');
    swift.push('        switch hex.count {');
    swift.push('        case 3: // RGB (12-bit)');
    swift.push('            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)');
    swift.push('        case 6: // RGB (24-bit)');
    swift.push('            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)');
    swift.push('        case 8: // ARGB (32-bit)');
    swift.push('            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)');
    swift.push('        default:');
    swift.push('            (a, r, g, b) = (1, 1, 1, 0)');
    swift.push('        }');
    swift.push('        self.init(');
    swift.push('            red: Double(r) / 255,');
    swift.push('            green: Double(g) / 255,');
    swift.push('            blue: Double(b) / 255,');
    swift.push('            alpha: Double(a) / 255');
    swift.push('        )');
    swift.push('    }');
    swift.push('}');
    return swift.join('\n');
  }

  generateAndroidXML(tokens) {
    const xml = [];
    xml.push('<?xml version="1.0" encoding="utf-8"?>');
    xml.push('<!-- Design Tokens - Auto-generated Android Resources -->');
    xml.push('<!-- Do not edit this file manually -->');
    xml.push('<resources>');
    xml.push('');
    
    // Colors
    if (tokens.colors) {
      xml.push('    <!-- Colors -->');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          // Nested structure: category -> shade -> value
          Object.entries(value).forEach(([shade, colorValue]) => {
            // Handle both simple string values and Figma Token Studio format
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              xml.push(`    <color name="${key}_${shade}">${actualValue}</color>`);
            }
          });
        } else {
          // Handle flat structure
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const colorName = key.replace(/-/g, '_');
            xml.push(`    <color name="${colorName}">${actualValue}</color>`);
          }
        }
      });
      xml.push('');
    }
    
    // Dimensions (spacing, border radius, font sizes)
    const dimensionTokens = [];
    
    if (tokens.spacing) {
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const dpValue = this.convertToDp(actualValue);
          dimensionTokens.push(`    <dimen name="spacing_${key}">${dpValue}</dimen>`);
        }
      });
    }
    
    if (tokens.borderRadius) {
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const dpValue = this.convertToDp(actualValue);
          dimensionTokens.push(`    <dimen name="border_radius_${key}">${dpValue}</dimen>`);
        }
      });
    }
    
    if (tokens.typography?.fontSize) {
      Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const spValue = this.convertToSp(actualValue);
          dimensionTokens.push(`    <dimen name="font_size_${key}">${spValue}</dimen>`);
        }
      });
    }
    
    if (dimensionTokens.length > 0) {
      xml.push('    <!-- Dimensions -->');
      xml.push(...dimensionTokens);
      xml.push('');
    }
    
    // Strings (font families)
    if (tokens.typography?.fontFamily) {
      xml.push('    <!-- Font Families -->');
      Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          // Extract first font from font stack for Android
          const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
          xml.push(`    <string name="font_family_${key}">${fontName}</string>`);
        }
      });
      xml.push('');
    }
    
    xml.push('</resources>');
    return xml.join('\n');
  }

  generateXamarinXAML(tokens) {
    const xaml = [];
    xaml.push('<?xml version="1.0" encoding="utf-8"?>');
    xaml.push('<!-- Design Tokens - Auto-generated Xamarin XAML Resources -->');
    xaml.push('<!-- Do not edit this file manually -->');
    xaml.push('<ResourceDictionary xmlns="http://xamarin.com/schemas/2014/forms"');
    xaml.push('                    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">');
    xaml.push('');
    
    // Colors
    if (tokens.colors) {
      xaml.push('    <!-- Colors -->');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          // Nested structure: category -> shade -> value
          Object.entries(value).forEach(([shade, colorValue]) => {
            // Handle both simple string values and Figma Token Studio format
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              const colorName = this.toPascalCase(`${key} ${shade}`);
              xaml.push(`    <Color x:Key="${colorName}">${actualValue}</Color>`);
            }
          });
        } else {
          // Handle flat structure
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const colorName = this.toPascalCase(key);
            xaml.push(`    <Color x:Key="${colorName}">${actualValue}</Color>`);
          }
        }
      });
      xaml.push('');
    }
    
    // Spacing/Dimensions
    if (tokens.spacing) {
      xaml.push('    <!-- Spacing -->');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          const spacingName = this.toPascalCase(`Spacing ${key}`);
          xaml.push(`    <x:Double x:Key="${spacingName}">${numericValue}</x:Double>`);
        }
      });
      xaml.push('');
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      xaml.push('    <!-- Border Radius -->');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          const radiusName = this.toPascalCase(`BorderRadius ${key}`);
          xaml.push(`    <x:Double x:Key="${radiusName}">${numericValue}</x:Double>`);
        }
      });
      xaml.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        xaml.push('    <!-- Font Sizes -->');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToPoints(actualValue);
            const fontSizeName = this.toPascalCase(`FontSize ${key}`);
            xaml.push(`    <x:Double x:Key="${fontSizeName}">${numericValue}</x:Double>`);
          }
        });
        xaml.push('');
      }
      
      if (tokens.typography.fontFamily) {
        xaml.push('    <!-- Font Families -->');
        Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            // Extract first font from font stack for Xamarin
            const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
            const fontFamilyName = this.toPascalCase(`FontFamily ${key}`);
            xaml.push(`    <x:String x:Key="${fontFamilyName}">${fontName}</x:String>`);
          }
        });
        xaml.push('');
      }
    }
    
    xaml.push('</ResourceDictionary>');
    return xaml.join('\n');
  }

  // Helper to quote keys if not valid JS identifiers
  jsKey(key) {
    return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `"${key}"`;
  }

  generateReactNativeContent(tokens) {
    const js = [];
    
    js.push('// Design Tokens - Auto-generated React Native Styles');
    js.push('// Do not edit this file manually');
    js.push('');
    
    // Colors
    if (tokens.colors) {
      js.push('export const colors = {');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          js.push(`  ${this.jsKey(this.toCamelCase(key))}: {`);
          Object.entries(value).forEach(([shade, colorValue]) => {
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              js.push(`    ${this.jsKey(this.toCamelCase(shade))}: '${actualValue}',`);
            }
          });
          js.push('  },');
        } else {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            js.push(`  ${this.jsKey(this.toCamelCase(key))}: '${actualValue}',`);
          }
        }
      });
      js.push('};');
      js.push('');
    }
    
    // Spacing
    if (tokens.spacing) {
      js.push('export const spacing = {');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          js.push(`  ${this.jsKey(this.toCamelCase(key))}: ${numericValue},`);
        }
      });
      js.push('};');
      js.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        js.push('export const fontSize = {');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToRNPoints(actualValue);
            js.push(`  ${this.jsKey(this.toCamelCase(key))}: ${numericValue},`);
          }
        });
        js.push('};');
        js.push('');
      }
      
      if (tokens.typography.fontFamily) {
        js.push('export const fontFamily = {');
        Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            // Extract first font from font stack for React Native
            const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
            js.push(`  ${this.jsKey(this.toCamelCase(key))}: '${fontName}',`);
          }
        });
        js.push('};');
        js.push('');
      }
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      js.push('export const borderRadius = {');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          js.push(`  ${this.jsKey(this.toCamelCase(key))}: ${numericValue},`);
        }
      });
      js.push('};');
      js.push('');
    }
    
    // Shadows for React Native
    if (tokens.shadows) {
      js.push('export const shadows = {');
      Object.entries(tokens.shadows).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const shadowStyle = this.convertToRNShadow(actualValue);
          js.push(`  ${this.jsKey(this.toCamelCase(key))}: ${JSON.stringify(shadowStyle, null, 4).replace(/\n/g, '\n    ')},`);
        }
      });
      js.push('};');
      js.push('');
    }
    
    // Combined export
    js.push('export const tokens = {');
    if (tokens.colors) js.push('  colors,');
    if (tokens.spacing) js.push('  spacing,');
    if (tokens.typography?.fontSize) js.push('  fontSize,');
    if (tokens.typography?.fontFamily) js.push('  fontFamily,');
    if (tokens.borderRadius) js.push('  borderRadius,');
    if (tokens.shadows) js.push('  shadows,');
    js.push('};');
    js.push('');
    js.push('export default tokens;');
    
    return js.join('\n');
  }

  generateFlutterContent(tokens) {
    const dart = [];
    
    dart.push('// Design Tokens - Auto-generated Flutter/Dart');
    dart.push('// Do not edit this file manually');
    dart.push('');
    dart.push('import \'package:flutter/material.dart\';');
    dart.push('');
    dart.push('class DesignTokens {');
    
    // Colors
    if (tokens.colors) {
      dart.push('  // Colors');
      dart.push('  static class Colors {');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          Object.entries(value).forEach(([shade, colorValue]) => {
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              const colorName = this.toCamelCase(`${key}_${shade}`);
              const flutterColor = this.convertToFlutterColor(actualValue);
              dart.push(`    static const Color ${colorName} = ${flutterColor};`);
            }
          });
        } else {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const colorName = this.toCamelCase(key);
            const flutterColor = this.convertToFlutterColor(actualValue);
            dart.push(`    static const Color ${colorName} = ${flutterColor};`);
          }
        }
      });
      dart.push('  }');
      dart.push('');
    }
    
    // Spacing
    if (tokens.spacing) {
      dart.push('  // Spacing');
      dart.push('  static class Spacing {');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          dart.push(`    static const double ${this.toCamelCase(key)} = ${numericValue};`);
        }
      });
      dart.push('  }');
      dart.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        dart.push('  // Font Sizes');
        dart.push('  static class FontSize {');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToRNPoints(actualValue);
            dart.push(`    static const double ${this.toCamelCase(key)} = ${numericValue};`);
          }
        });
        dart.push('  }');
        dart.push('');
      }
      
      if (tokens.typography.fontFamily) {
        dart.push('  // Font Families');
        dart.push('  static class FontFamily {');
        Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
            dart.push(`    static const String ${this.toCamelCase(key)} = '${fontName}';`);
          }
        });
        dart.push('  }');
        dart.push('');
      }
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      dart.push('  // Border Radius');
      dart.push('  static class BorderRadius {');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          dart.push(`    static const double ${this.toCamelCase(key)} = ${numericValue};`);
        }
      });
      dart.push('  }');
      dart.push('');
    }
    
    // Shadows
    if (tokens.shadows) {
      dart.push('  // Shadows');
      dart.push('  static class Shadows {');
      Object.entries(tokens.shadows).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const shadowProps = this.parseCSShadow(actualValue);
          const flutterColor = this.convertToFlutterColor(shadowProps.color);
          dart.push(`    static const BoxShadow ${this.toCamelCase(key)} = BoxShadow(`);
          dart.push(`      offset: Offset(${shadowProps.x}, ${shadowProps.y}),`);
          dart.push(`      blurRadius: ${shadowProps.blur},`);
          dart.push(`      color: ${flutterColor},`);
          dart.push('    );');
        }
      });
      dart.push('  }');
      dart.push('');
    }
    
    dart.push('}');
    
    return dart.join('\n');
  }

  generateKotlinComposeContent(tokens) {
    const kt = [];
    
    kt.push('// Design Tokens - Auto-generated Kotlin Compose');
    kt.push('// Do not edit this file manually');
    kt.push('');
    kt.push('package com.yourapp.designtokens');
    kt.push('');
    kt.push('import androidx.compose.ui.graphics.Color');
    kt.push('import androidx.compose.ui.unit.dp');
    kt.push('import androidx.compose.ui.unit.sp');
    kt.push('');
    kt.push('object DesignTokens {');
    
    // Colors
    if (tokens.colors) {
      kt.push('    object Colors {');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          Object.entries(value).forEach(([shade, colorValue]) => {
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              const colorName = this.toPascalCase(`${key}_${shade}`);
              const composeColor = this.convertToComposeColor(actualValue);
              kt.push(`        val ${colorName} = ${composeColor}`);
            }
          });
        } else {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const colorName = this.toPascalCase(key);
            const composeColor = this.convertToComposeColor(actualValue);
            kt.push(`        val ${colorName} = ${composeColor}`);
          }
        }
      });
      kt.push('    }');
      kt.push('');
    }
    
    // Spacing
    if (tokens.spacing) {
      kt.push('    object Spacing {');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          kt.push(`        val ${this.toPascalCase(key)} = ${numericValue}.dp`);
        }
      });
      kt.push('    }');
      kt.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        kt.push('    object FontSize {');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToRNPoints(actualValue);
            kt.push(`        val ${this.toPascalCase(key)} = ${numericValue}.sp`);
          }
        });
        kt.push('    }');
        kt.push('');
      }
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      kt.push('    object BorderRadius {');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          kt.push(`        val ${this.toPascalCase(key)} = ${numericValue}.dp`);
        }
      });
      kt.push('    }');
      kt.push('');
    }
    
    kt.push('}');
    
    return kt.join('\n');
  }

  generateSwiftUIContent(tokens) {
    const swift = [];
    
    swift.push('// Design Tokens - Auto-generated SwiftUI');
    swift.push('// Do not edit this file manually');
    swift.push('');
    swift.push('import SwiftUI');
    swift.push('');
    swift.push('struct DesignTokens {');
    
    // Colors
    if (tokens.colors) {
      swift.push('    struct Colors {');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          Object.entries(value).forEach(([shade, colorValue]) => {
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              const colorName = this.toCamelCase(`${key}_${shade}`);
              const swiftUIColor = this.convertToSwiftUIColor(actualValue);
              swift.push(`        static let ${colorName} = ${swiftUIColor}`);
            }
          });
        } else {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const colorName = this.toCamelCase(key);
            const swiftUIColor = this.convertToSwiftUIColor(actualValue);
            swift.push(`        static let ${colorName} = ${swiftUIColor}`);
          }
        }
      });
      swift.push('    }');
      swift.push('');
    }
    
    // Spacing
    if (tokens.spacing) {
      swift.push('    struct Spacing {');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          swift.push(`        static let ${this.toCamelCase(key)}: CGFloat = ${numericValue}`);
        }
      });
      swift.push('    }');
      swift.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        swift.push('    struct FontSize {');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToPoints(actualValue);
            swift.push(`        static let ${this.toCamelCase(key)}: CGFloat = ${numericValue}`);
          }
        });
        swift.push('    }');
        swift.push('');
      }
      
      if (tokens.typography.fontFamily) {
        swift.push('    struct FontFamily {');
        Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
            swift.push(`        static let ${this.toCamelCase(key)} = "${fontName}"`);
          }
        });
        swift.push('    }');
        swift.push('');
      }
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      swift.push('    struct BorderRadius {');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          swift.push(`        static let ${this.toCamelCase(key)}: CGFloat = ${numericValue}`);
        }
      });
      swift.push('    }');
      swift.push('');
    }
    
    swift.push('}');
    
    return swift.join('\n');
  }

  /**
   * Generate JSON output
   */
  async generateJSON(tokens, outputPath) {
    const jsonContent = this.generateJSONContent(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, jsonContent);
    
    console.log(`✅ Generated JSON: ${outputPath}`);
    return { path: outputPath, content: jsonContent };
  }

  generateJSONContent(tokens) {
    // Create a clean JSON output with metadata
    const output = {
      $schema: 'https://schemas.figma.com/figma-tokens/1.0.0',
      $metadata: {
        generatedBy: 'design-tokens-sync',
        generatedAt: new Date().toISOString(),
        version: '1.0.0'
      },
      ...tokens
    };

    // Remove internal metadata
    delete output.source;
    delete output.lastLoaded;

    return JSON.stringify(output, null, 2);
  }

  /**
   * Generate JavaScript/ES module output
   */
  async generateJavaScript(tokens, outputPath) {
    const jsContent = this.generateJavaScriptContent(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, jsContent);
    
    console.log(`✅ Generated JavaScript: ${outputPath}`);
    return { path: outputPath, content: jsContent };
  }

  generateJavaScriptContent(tokens) {
    const js = [];
    
    js.push('// Design Tokens - Auto-generated JavaScript/ES Module');
    js.push('// Do not edit this file manually');
    js.push('');

    // Create clean tokens object without internal metadata
    const cleanTokens = { ...tokens };
    delete cleanTokens.source;
    delete cleanTokens.lastLoaded;

    js.push('// Design tokens as JavaScript object');
    js.push(`export const tokens = ${JSON.stringify(cleanTokens, null, 2)};`);
    js.push('');

    // Add individual exports for each category
    if (cleanTokens.colors) {
      js.push('// Individual category exports');
      js.push(`export const colors = ${JSON.stringify(cleanTokens.colors, null, 2)};`);
    }

    if (cleanTokens.spacing) {
      js.push(`export const spacing = ${JSON.stringify(cleanTokens.spacing, null, 2)};`);
    }

    if (cleanTokens.typography) {
      js.push(`export const typography = ${JSON.stringify(cleanTokens.typography, null, 2)};`);
    }

    if (cleanTokens.borderRadius) {
      js.push(`export const borderRadius = ${JSON.stringify(cleanTokens.borderRadius, null, 2)};`);
    }

    if (cleanTokens.shadows) {
      js.push(`export const shadows = ${JSON.stringify(cleanTokens.shadows, null, 2)};`);
    }

    if (cleanTokens.opacity) {
      js.push(`export const opacity = ${JSON.stringify(cleanTokens.opacity, null, 2)};`);
    }

    js.push('');
    js.push('// Default export');
    js.push('export default tokens;');

    return js.join('\n');
  }

  /**
   * Generate CommonJS tokens module matching ESM shape
   */
  async generateTokensCjs(tokens, outputPath) {
    const cleanTokens = { ...tokens };
    delete cleanTokens.source;
    delete cleanTokens.lastLoaded;

    const obj = {
      tokens: cleanTokens,
      ...(cleanTokens.colors ? { colors: cleanTokens.colors } : {}),
      ...(cleanTokens.spacing ? { spacing: cleanTokens.spacing } : {}),
      ...(cleanTokens.typography ? { typography: cleanTokens.typography } : {}),
      ...(cleanTokens.borderRadius ? { borderRadius: cleanTokens.borderRadius } : {}),
      ...(cleanTokens.shadows ? { shadows: cleanTokens.shadows } : {}),
      ...(cleanTokens.opacity ? { opacity: cleanTokens.opacity } : {})
    };

    const cjs = [
      '// Design Tokens - Auto-generated CommonJS Module',
      '// Do not edit this file manually',
      '',
      `module.exports = ${JSON.stringify(obj, null, 2)};`,
      'module.exports.default = module.exports.tokens;',
      ''
    ].join('\n');

    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, cjs);
    console.log(`✅ Generated Tokens (CJS): ${outputPath}`);
    return { path: outputPath, content: cjs };
  }

  /**
   * Generate shadcn theme CSS for :root and .dark
   */
  async generateShadcnThemeCss(tokens, outputPath, options = {}) {
    const content = this.buildShadcnThemeCss(tokens, options);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    console.log(`✅ Generated shadcn theme CSS: ${outputPath}`);
    return { path: outputPath, content };
  }

  buildShadcnThemeCss(tokens, { hsl = true, mapping = {}, format = 'hsl', strict = false, fallback = 'shadcn', extend = {} } = {}) {
    const get = (obj, pathStr) => pathStr.split('.').reduce((o, k) => (o && o[k] !== undefined ? o[k] : undefined), obj);
    
    // Smart color getter that tries multiple path patterns
    const color = (paths, hardcodedFallback) => {
      const pathsToTry = Array.isArray(paths) ? paths : [paths];
      
      for (const pathStr of pathsToTry) {
        // Try the path as-is first
        let v = get(tokens, pathStr);
        
        // If not found and doesn't start with 'core', try prefixing with 'core.'
        if (v === undefined && !pathStr.startsWith('core.')) {
          v = get(tokens, `core.${pathStr}`);
        }
        
        // Handle Token Studio format (object with value property)
        if (v && typeof v === 'object' && v.value !== undefined) {
          v = v.value;
        }
        
        // If we found a valid value, check if it's a Token Studio reference
        if (typeof v === 'string' && v.length > 0) {
          // Handle Token Studio references like "{core.colors.blue.500}"
          if (v.startsWith('{') && v.endsWith('}')) {
            const refPath = v.slice(1, -1); // Remove { }
            let refValue = get(tokens, refPath);
            
            // Handle nested Token Studio format
            if (refValue && typeof refValue === 'object' && refValue.value !== undefined) {
              refValue = refValue.value;
            }
            
            if (typeof refValue === 'string' && refValue.length > 0) {
              return this.formatColorForShadcn(refValue, format);
            }
          } else {
            // Direct color value
            return this.formatColorForShadcn(v, format);
          }
        }
      }
      
      // Fallback behavior
      if (strict || fallback === 'none') {
        // In strict mode or explicit none fallback, return an empty string to omit var
        return '';
      }
      return this.formatColorForShadcn(hardcodedFallback, format);
    };

    // Try to get radius from multiple possible paths
    const radiusPaths = ['borderRadius.md', 'core.borderRadius.md', 'borderRadius.base', 'core.borderRadius.base'];
    let radius = '0.375rem';
    for (const path of radiusPaths) {
      const r = get(tokens, path);
      if (r) {
        radius = (typeof r === 'object' && r.value) ? r.value : r;
        break;
      }
    }

    // Defaults with multiple path fallbacks (can be overridden by mapping)
    const light = {
      background: color([
        'semantic.colors.background.primary',
        'semantic.colors.background.secondary',
        // Transformed tokens place semantic under colors
        'colors.background.primary',
        'colors.background.secondary',
        'colors.gray.50',
        'colors.neutral.50',
        'colors.primary.50'
      ], '#ffffff'),
      foreground: color([
        'semantic.colors.text.primary',
        'colors.text.primary',
        'colors.gray.900',
        'colors.neutral.900',
        'colors.primary.900'
      ], '#111827'),
      primary: color([
        'semantic.colors.brand.primary',
        'colors.brand.primary',
        'colors.blue.500',
        'colors.primary.500',
        'colors.primary.600'
      ], '#3b82f6'),
      'primary-foreground': color([
        'semantic.colors.text.inverse',
        'colors.gray.50',
        'colors.neutral.50',
        'colors.primary.50'
      ], '#f9fafb'),
      secondary: color([
        'semantic.colors.background.tertiary',
        'colors.background.tertiary',
        'colors.gray.100',
        'colors.neutral.100',
        'colors.primary.100'
      ], '#f3f4f6'),
      'secondary-foreground': color([
        'semantic.colors.text.secondary',
        'colors.text.secondary',
        'colors.gray.900',
        'colors.neutral.900'
      ], '#111827'),
      muted: color([
        'semantic.colors.background.tertiary',
        'colors.gray.100',
        'colors.neutral.100'
      ], '#f3f4f6'),
      'muted-foreground': color([
        'semantic.colors.text.muted',
        'colors.text.muted',
        'colors.gray.600',
        'colors.neutral.600'
      ], '#4b5563'),
      accent: color([
        'colors.gray.100',
        'colors.neutral.100'
      ], '#f3f4f6'),
      'accent-foreground': color([
        'semantic.colors.text.primary',
        'colors.gray.900',
        'colors.neutral.900'
      ], '#111827'),
      destructive: color([
        'semantic.colors.feedback.error',
        'colors.feedback.error',
        'colors.red.500',
        'colors.error.100',
        'colors.error.300',
        'colors.red.600'
      ], '#ef4444'),
      'destructive-foreground': color([
        'semantic.colors.text.inverse',
        'colors.gray.50',
        'colors.neutral.50'
      ], '#f9fafb'),
      border: color([
        // Prefer transformed semantic under colors
        'colors.border.default',
        'colors.border.light',
        // Also try raw semantic path in case of direct use
        'semantic.colors.border.default',
        'semantic.colors.border.light',
        // Prefer lighter gray before darker
        'colors.gray.200',
        'colors.neutral.200',
        'colors.gray.500'
      ], '#e5e7eb'),
      input: color([
        'colors.border.default',
        'semantic.colors.border.default',
        'colors.gray.200',
        'colors.neutral.200',
        'colors.gray.500'
      ], '#e5e7eb'),
      ring: color([
        'semantic.colors.brand.primary',
        'colors.brand.primary',
        'colors.primary.500'
      ], '#3b82f6'),
      radius
    };
    
    // Dark mode - try to use appropriate dark variants
    const dark = {
      background: color([
        'semantic.colors.background.inverse',
        'colors.background.inverse',
        'colors.primary.500',
        'colors.gray.900',
        'colors.neutral.900'
      ], '#0b1220'),
      foreground: color([
        'semantic.colors.text.inverse',
        'colors.gray.50',
        'colors.neutral.50'
      ], '#f9fafb'),
      primary: color([
        'semantic.colors.brand.secondary',
        'colors.brand.secondary',
        'colors.primary.600',
        'colors.primary.500'
      ], '#2563eb'),
      'primary-foreground': color([
        'semantic.colors.text.inverse',
        'colors.gray.50',
        'colors.neutral.50'
      ], '#f9fafb'),
      secondary: color([
        'colors.gray.800',
        'colors.neutral.800',
        'colors.primary.800'
      ], '#1f2937'),
      'secondary-foreground': color([
        'semantic.colors.text.inverse',
        'colors.gray.50',
        'colors.neutral.50'
      ], '#f9fafb'),
      muted: color([
        'colors.gray.800',
        'colors.neutral.800'
      ], '#1f2937'),
      'muted-foreground': color([
        'colors.gray.400',
        'colors.neutral.400'
      ], '#9ca3af'),
      accent: color([
        'colors.gray.800',
        'colors.neutral.800'
      ], '#1f2937'),
      'accent-foreground': color([
        'semantic.colors.text.inverse',
        'colors.gray.50',
        'colors.neutral.50'
      ], '#f9fafb'),
      destructive: color([
        'semantic.colors.feedback.error',
        'colors.error.100',
        'colors.error.300',
        'colors.red.600'
      ], '#dc2626'),
      'destructive-foreground': color([
        'semantic.colors.text.inverse',
        'colors.gray.50',
        'colors.neutral.50'
      ], '#f9fafb'),
      border: color([
        'colors.gray.800',
        'colors.neutral.800',
        'colors.primary.800'
      ], '#1f2937'),
      input: color([
        'colors.gray.800',
        'colors.neutral.800'
      ], '#1f2937'),
      ring: color([
        'semantic.colors.brand.secondary',
        'colors.brand.secondary',
        'colors.primary.600'
      ], '#2563eb'),
      radius
    };

    // Apply mapping overrides
    const resolveMappingRef = (refPath) => {
      // Try as-is against transformed tokens
      let val = get(tokens, refPath);
      if (val !== undefined) return val;

      // Map Token Studio-style paths to transformed structure
      const candidates = [];
      // colors
      candidates.push(refPath.replace(/^core\.colors\./, 'colors.'));
      candidates.push(refPath.replace(/^semantic\.colors\./, 'colors.'));
      // non-color categories
      candidates.push(refPath.replace(/^core\./, ''));
      candidates.push(refPath.replace(/^semantic\./, ''));
      // semantic colors sometimes reside under colors.* after transform
      if (refPath.startsWith('semantic.colors.')) {
        const rest = refPath.replace(/^semantic\.colors\./, '');
        candidates.push(`colors.${rest}`);
      }
      for (const candidate of candidates) {
        if (!candidate || candidate === refPath) continue;
        val = get(tokens, candidate);
        if (val !== undefined) return val;
      }
      return undefined;
    };

    const applyOverrides = (target, overrides) => {
      Object.entries(overrides || {}).forEach(([k, v]) => {
        if (typeof v === 'string') {
          // If it's a token reference, resolve it first
          if (v.startsWith('{') && v.endsWith('}')) {
            const tokenPath = v.slice(1, -1); // Remove { }
            // Try to get the actual value
            let resolvedValue = resolveMappingRef(tokenPath);

            // Handle Token Studio format (object with value property)
            if (resolvedValue && typeof resolvedValue === 'object' && resolvedValue.value !== undefined) {
              resolvedValue = resolvedValue.value;
            }
            
            // Handle array values (like font families)
            if (Array.isArray(resolvedValue)) {
              resolvedValue = resolvedValue.join(', ');
            }
            
            // If we found a value, use it, otherwise use fallback
            if (resolvedValue !== undefined) {
              // For non-color values (spacing, typography, etc.), don't convert to HSL
              const isColorValue = k.includes('color') || k.includes('background') || k.includes('foreground') || 
                                 k.includes('border') || k.includes('primary') || k.includes('secondary') ||
                                 k.includes('destructive') || k.includes('ring') || k.includes('muted') ||
                                 k.includes('accent') || k.includes('input');
              target[k] = isColorValue ? this.formatColorForShadcn(resolvedValue, format) : resolvedValue;
            } else {
              target[k] = v; // Keep as fallback if resolution fails
            }
          } else {
            // If it's a direct value, format appropriately
            const isColorValue = k.includes('color') || k.includes('background') || k.includes('foreground') || 
                               k.includes('border') || k.includes('primary') || k.includes('secondary') ||
                               k.includes('destructive') || k.includes('ring') || k.includes('muted') ||
                               k.includes('accent') || k.includes('input');
            target[k] = isColorValue ? this.formatColorForShadcn(v, format) : v;
          }
        }
      });
    };
    applyOverrides(light, mapping.light);
    applyOverrides(dark, mapping.dark);

    const toCssVars = (obj, includeComments = false) => {
      return Object.entries(obj)
        .map(([k, v]) => {
          if (k === 'radius') {
            return `  --${k}: ${v};`;
          }
          
          if (!v) {
            // Skip undefined/empty values (strict mode omission)
            return null;
          }

          if (includeComments && format === 'rgb' && typeof v === 'string' && v.includes(' ')) {
            // Try to convert RGB back to hex for comment
            const rgbMatch = v.match(/^(\d+)\s+(\d+)\s+(\d+)$/);
            if (rgbMatch) {
              const [, r, g, b] = rgbMatch;
              const hex = '#' + [r, g, b].map(x => parseInt(x).toString(16).padStart(2, '0').toUpperCase()).join('');
              return `  --${k}: ${v}; /* ${hex} */`;
            }
          }
          
          return `  --${k}: ${v};`;
        })
        .filter(Boolean)
        .join('\n');
    };

    const includeComments = format === 'rgb';
    const lightComment = includeComments ? '  /* Map design tokens to shadcn variables */' : '';
    
    const lines = [
      ':root {',
      lightComment,
      toCssVars(light, includeComments)
    ];

    // Extended palettes
    if (extend && extend.palettes && tokens.colors) {
      const addPalette = (prefix, obj) => {
        if (!obj || typeof obj !== 'object') return;
        Object.entries(obj).forEach(([shade, val]) => {
          if (typeof val === 'string') {
            lines.push(`  --${prefix}-${shade}: ${this.formatColorForShadcn(val, format)};`);
          } else if (val && typeof val === 'object') {
            addPalette(`${prefix}-${shade}`, val);
          }
        });
      };

      // Emit color scales by category
      const categories = ['primary', 'gray', 'success', 'warning', 'error', 'info', 'neutral'];
      categories.forEach(name => {
        if (tokens.colors[name]) addPalette(name, tokens.colors[name]);
      });

      // Root success/warning/etc values with foreground
      const fg = (tokens.colors.gray && tokens.colors.gray['50']) || '#FFFFFF';
      ['success','warning','error','info','neutral'].forEach(g => {
        const group = tokens.colors[g];
        if (group && group['100']) {
          lines.push(`  --${g}: ${this.formatColorForShadcn(group['100'], format)};`);
          lines.push(`  --${g}-foreground: ${this.formatColorForShadcn(fg, format)};`);
        }
      });
    }

    // Extended semantic
    if (extend && extend.semantic && tokens.colors) {
      // In 'actual' profile, the baseline shadcn vars already cover semantic highlights.
      // Avoid emitting extra text/background/border/brand keys to match expected shape.
      if (!extend.profile || extend.profile !== 'actual') {
        const tryGet = (p) => p.split('.').reduce((o, k) => (o && o[k] !== undefined ? o[k] : undefined), tokens);
        const pushIf = (key, val) => { if (val) lines.push(`  --${key}: ${this.formatColorForShadcn(val, format)};`); };
        pushIf('text-primary', tryGet('colors.text.primary'));
        pushIf('text-secondary', tryGet('colors.text.secondary'));
        pushIf('text-tertiary', tryGet('colors.text.tertiary'));
        pushIf('text-inverse', tryGet('colors.text.inverse'));
        pushIf('text-muted', tryGet('colors.text.muted'));
        pushIf('background-primary', tryGet('colors.background.primary'));
        pushIf('background-secondary', tryGet('colors.background.secondary'));
        pushIf('background-tertiary', tryGet('colors.background.tertiary'));
        pushIf('background-inverse', tryGet('colors.background.inverse'));
        pushIf('border-default', tryGet('colors.border.default'));
        pushIf('border-hover', tryGet('colors.border.hover'));
        pushIf('border-focus', tryGet('colors.border.focus'));
        pushIf('border-light', tryGet('colors.border.light'));
        if (extend.includeBrand !== false) {
          pushIf('brand-primary', tryGet('colors.brand.primary'));
          pushIf('brand-secondary', tryGet('colors.brand.secondary'));
          pushIf('brand-tertiary', tryGet('colors.brand.tertiary'));
        }
      }
    }

    // Extended radii
    if (extend && extend.radii && tokens.borderRadius) {
      const r = tokens.borderRadius;
      if (r.sm) lines.push(`  --radius-sm: ${r.sm};`);
      if (r.lg) lines.push(`  --radius-lg: ${r.lg};`);
      if (r.xl) lines.push(`  --radius-xl: ${r.xl};`);
      if (r['2xl']) lines.push(`  --radius-2xl: ${r['2xl']};`);
      if (r.full) lines.push(`  --radius-full: ${r.full};`);
    }

    // Extended spacing
    if (extend && extend.spacing && tokens.spacing) {
      const subset = Array.isArray(extend.spacingSubset) && extend.spacingSubset.length > 0
        ? extend.spacingSubset
        : (extend.profile === 'actual'
            ? ['0','1','2','3','4','5','6','8','10','12','16','20','24']
            : null);
      if (subset) {
        subset.forEach(k => { if (tokens.spacing[k]) lines.push(`  --spacing-${k}: ${tokens.spacing[k]};`); });
      } else {
        Object.entries(tokens.spacing).forEach(([k, v]) => lines.push(`  --spacing-${k}: ${v};`));
      }
    }

    // Extended typography
    if (extend && extend.typography && tokens.typography) {
      const t = tokens.typography;
      const quoteIfNeeded = (s) => (typeof s === 'string' && /[^A-Za-z0-9_-]/.test(s) ? `"${s}"` : s);
      if (t.fontFamily?.sans) {
        const val = Array.isArray(t.fontFamily.sans) ? t.fontFamily.sans.map(quoteIfNeeded).join(', ') : t.fontFamily.sans;
        lines.push(`  --font-sans: ${val};`);
      }
      if (t.fontFamily?.mono) {
        const val = Array.isArray(t.fontFamily.mono) ? t.fontFamily.mono.map(quoteIfNeeded).join(', ') : t.fontFamily.mono;
        lines.push(`  --font-mono: ${val};`);
      }
      Object.entries(t.fontSize || {}).forEach(([k, v]) => lines.push(`  --font-size-${k}: ${v};`));
      Object.entries(t.fontWeight || {}).forEach(([k, v]) => lines.push(`  --font-weight-${k}: ${v};`));
      Object.entries(t.lineHeight || {}).forEach(([k, v]) => lines.push(`  --line-height-${k}: ${v};`));
    }

    // Extended shadows
    if (extend && extend.shadows && tokens.shadows) {
      Object.entries(tokens.shadows).forEach(([k, v]) => lines.push(`  --shadow-${k}: ${v};`));
    }

    // Close :root and write .dark
    lines.push('}', '', '.dark {', toCssVars(dark, includeComments), '}');

    return lines.filter(line => line !== '').join('\n');
  }

  formatColor(value, hsl = true) {
    if (!value) return hsl ? '0 0% 100%' : '#ffffff';
    if (!hsl) return value;
    if (value.startsWith('#')) return this.hexToHslTriple(value);
    if (value.startsWith('rgb')) {
      // naive rgb to hsl conversion fallback
      try {
        const m = value.match(/rgba?\(([^)]+)\)/);
        if (m) {
          const [r, g, b] = m[1].split(',').slice(0, 3).map((n) => parseFloat(n.trim()));
          return this.rgbToHslTriple(r, g, b);
        }
      } catch {}
    }
    return value;
  }

  formatColorForShadcn(value, format = 'hsl') {
    if (!value) return format === 'hsl' ? '0 0% 100%' : '255 255 255';
    
    if (format === 'rgb') {
      // Convert to RGB format for shadcn
      if (value.startsWith('#')) {
        return this.hexToRgbTriple(value);
      }
      if (value.startsWith('rgb')) {
        const m = value.match(/rgba?\(([^)]+)\)/);
        if (m) {
          const [r, g, b] = m[1].split(',').slice(0, 3).map((n) => Math.round(parseFloat(n.trim())));
          return `${r} ${g} ${b}`;
        }
      }
      return value;
    } else {
      // Default HSL format
      return this.formatColor(value, true);
    }
  }

  hexToHslTriple(hex) {
    const c = hex.replace('#', '');
    const bigint = c.length === 3
      ? parseInt(c.split('').map((ch) => ch + ch).join(''), 16)
      : parseInt(c, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return this.rgbToHslTriple(r, g, b);
  }

  hexToRgbTriple(hex) {
    const c = hex.replace('#', '');
    const bigint = c.length === 3
      ? parseInt(c.split('').map((ch) => ch + ch).join(''), 16)
      : parseInt(c, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `${r} ${g} ${b}`;
  }

  rgbToHslTriple(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 3; break;
        case b: h = (r - g) / d + 4; break;
      }
      h *= 60;
    }
    const H = Math.round(h || 0);
    const S = Math.round(s * 100);
    const L = Math.round(l * 100);
    return `${H} ${S}% ${L}%`;
  }
} 