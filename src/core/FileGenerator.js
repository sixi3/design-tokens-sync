import fs from 'fs-extra';
import path from 'path';

/**
 * File generation engine
 * Generates CSS, Tailwind, TypeScript, and other output formats from design tokens
 */
export class FileGenerator {
  constructor(options = {}) {
    this.options = options;
  }

  /**
   * Generate all configured output files
   */
  async generateAll(tokens, config) {
    const results = {};

    // Generate CSS custom properties
    if (config.output.css) {
      results.css = await this.generateCSS(tokens, config.output.css);
    }

    // Generate Tailwind config
    if (config.output.tailwind) {
      results.tailwind = await this.generateTailwindConfig(tokens, config.output.tailwind);
    }

    // Generate TypeScript definitions
    if (config.output.typescript) {
      results.typescript = await this.generateTypeScript(tokens, config.output.typescript);
    }

    // Generate SCSS variables
    if (config.output.scss) {
      results.scss = await this.generateSCSS(tokens, config.output.scss);
    }

    // Generate iOS Swift
    if (config.output.ios) {
      results.ios = await this.generateIOS(tokens, config.output.ios);
    }

    // Generate Android XML
    if (config.output.android) {
      results.android = await this.generateAndroid(tokens, config.output.android);
    }

    // Generate Xamarin (if implemented)
    if (config.output.xamarin) {
      results.xamarin = await this.generateXamarin(tokens, config.output.xamarin);
    }

    // Generate React Native
    if (config.output.reactNative) {
      results.reactNative = await this.generateReactNative(tokens, config.output.reactNative);
    }

    // Generate Flutter/Dart
    if (config.output.flutter) {
      results.flutter = await this.generateFlutter(tokens, config.output.flutter);
    }

    // Generate Kotlin Compose
    if (config.output.kotlinCompose) {
      results.kotlinCompose = await this.generateKotlinCompose(tokens, config.output.kotlinCompose);
    }

    // Generate SwiftUI
    if (config.output.swiftui) {
      results.swiftui = await this.generateSwiftUI(tokens, config.output.swiftui);
    }

    // Generate JSON output
    if (config.output.json) {
      results.json = await this.generateJSON(tokens, config.output.json);
    }

    // Generate JavaScript output
    if (config.output.javascript) {
      results.javascript = await this.generateJavaScript(tokens, config.output.javascript);
    }

    return results;
  }

  /**
   * Generate CSS custom properties file
   */
  async generateCSS(tokens, outputPath) {
    const css = this.generateCSSCustomProperties(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, css);
    
    console.log(`✅ Generated CSS: ${outputPath}`);
    return { path: outputPath, content: css };
  }

  /**
   * Generate CSS custom properties string
   */
  generateCSSCustomProperties(tokens) {
    const cssVars = [];
    
    // Header comment
    cssVars.push('/* Design Tokens - Auto-generated */');
    cssVars.push('/* Do not edit this file manually */');
    cssVars.push('');
    cssVars.push(':root {');

    // Colors
    if (tokens.colors) {
      cssVars.push('  /* Colors */');
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.entries(shades).forEach(([shade, value]) => {
            cssVars.push(`  --color-${category}-${shade}: ${value};`);
          });
        }
      });
      cssVars.push('');
    }

    // Spacing
    if (tokens.spacing) {
      cssVars.push('  /* Spacing */');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        cssVars.push(`  --spacing-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Border Radius
    if (tokens.borderRadius) {
      cssVars.push('  /* Border Radius */');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        cssVars.push(`  --border-radius-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Typography
    if (tokens.typography) {
      cssVars.push('  /* Typography */');
      Object.entries(tokens.typography).forEach(([category, values]) => {
        if (values && typeof values === 'object') {
          Object.entries(values).forEach(([key, value]) => {
            cssVars.push(`  --typography-${category}-${key}: ${value};`);
          });
        }
      });
      cssVars.push('');
    }

    // Shadows
    if (tokens.shadows) {
      cssVars.push('  /* Shadows */');
      Object.entries(tokens.shadows).forEach(([key, value]) => {
        cssVars.push(`  --shadow-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Opacity
    if (tokens.opacity) {
      cssVars.push('  /* Opacity */');
      Object.entries(tokens.opacity).forEach(([key, value]) => {
        cssVars.push(`  --opacity-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Z-Index
    if (tokens.zIndex) {
      cssVars.push('  /* Z-Index */');
      Object.entries(tokens.zIndex).forEach(([key, value]) => {
        cssVars.push(`  --z-index-${key}: ${value};`);
      });
      cssVars.push('');
    }

    // Transitions
    if (tokens.transitions) {
      cssVars.push('  /* Transitions */');
      if (tokens.transitions.duration) {
        Object.entries(tokens.transitions.duration).forEach(([key, value]) => {
          cssVars.push(`  --transition-duration-${key}: ${value};`);
        });
      }
      if (tokens.transitions.easing) {
        Object.entries(tokens.transitions.easing).forEach(([key, value]) => {
          cssVars.push(`  --transition-easing-${key}: ${value};`);
        });
      }
      cssVars.push('');
    }

    // Breakpoints
    if (tokens.breakpoints) {
      cssVars.push('  /* Breakpoints */');
      Object.entries(tokens.breakpoints).forEach(([key, value]) => {
        cssVars.push(`  --breakpoint-${key}: ${value};`);
      });
      cssVars.push('');
    }

    cssVars.push('}');
    cssVars.push('');

    // Add utility classes
    cssVars.push('/* Utility Classes */');
    
    // Text colors
    if (tokens.colors) {
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.keys(shades).forEach(shade => {
            cssVars.push(`.text-${category}-${shade} { color: var(--color-${category}-${shade}); }`);
          });
        }
      });
    }

    return cssVars.join('\n');
  }

  /**
   * Generate Tailwind configuration
   */
  async generateTailwindConfig(tokens, outputPath) {
    const configContent = this.generateTailwindConfigContent(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, configContent);
    
    console.log(`✅ Generated Tailwind config: ${outputPath}`);
    return { path: outputPath, content: configContent };
  }

  /**
   * Generate Tailwind configuration content
   */
  generateTailwindConfigContent(tokens) {
    const config = {
      theme: {
        extend: {}
      }
    };

    // Colors
    if (tokens.colors && Object.keys(tokens.colors).length > 0) {
      config.theme.extend.colors = tokens.colors;
    }

    // Spacing
    if (tokens.spacing && Object.keys(tokens.spacing).length > 0) {
      config.theme.extend.spacing = tokens.spacing;
    }

    // Border Radius
    if (tokens.borderRadius && Object.keys(tokens.borderRadius).length > 0) {
      config.theme.extend.borderRadius = tokens.borderRadius;
    }

    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontFamily && Object.keys(tokens.typography.fontFamily).length > 0) {
        config.theme.extend.fontFamily = tokens.typography.fontFamily;
      }
      if (tokens.typography.fontSize && Object.keys(tokens.typography.fontSize).length > 0) {
        config.theme.extend.fontSize = tokens.typography.fontSize;
      }
      if (tokens.typography.fontWeight && Object.keys(tokens.typography.fontWeight).length > 0) {
        config.theme.extend.fontWeight = tokens.typography.fontWeight;
      }
      if (tokens.typography.lineHeight && Object.keys(tokens.typography.lineHeight).length > 0) {
        config.theme.extend.lineHeight = tokens.typography.lineHeight;
      }
      if (tokens.typography.letterSpacing && Object.keys(tokens.typography.letterSpacing).length > 0) {
        config.theme.extend.letterSpacing = tokens.typography.letterSpacing;
      }
    }

    // Shadows
    if (tokens.shadows && Object.keys(tokens.shadows).length > 0) {
      config.theme.extend.boxShadow = tokens.shadows;
    }

    // Opacity
    if (tokens.opacity && Object.keys(tokens.opacity).length > 0) {
      config.theme.extend.opacity = tokens.opacity;
    }

    // Z-Index
    if (tokens.zIndex && Object.keys(tokens.zIndex).length > 0) {
      config.theme.extend.zIndex = tokens.zIndex;
    }

    // Transitions
    if (tokens.transitions) {
      if (tokens.transitions.duration && Object.keys(tokens.transitions.duration).length > 0) {
        config.theme.extend.transitionDuration = tokens.transitions.duration;
      }
      if (tokens.transitions.easing && Object.keys(tokens.transitions.easing).length > 0) {
        config.theme.extend.transitionTimingFunction = tokens.transitions.easing;
      }
    }

    // Breakpoints
    if (tokens.breakpoints && Object.keys(tokens.breakpoints).length > 0) {
      config.theme.extend.screens = tokens.breakpoints;
    }

    const configString = `/** @type {import('tailwindcss').Config} */
// Design Tokens - Auto-generated Tailwind Configuration
// Do not edit this file manually

export default ${JSON.stringify(config, null, 2)};
`;

    return configString;
  }

  /**
   * Generate TypeScript definitions
   */
  async generateTypeScript(tokens, outputPath) {
    const typeDefinitions = this.generateTypeDefinitions(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, typeDefinitions);
    
    console.log(`✅ Generated TypeScript definitions: ${outputPath}`);
    return { path: outputPath, content: typeDefinitions };
  }

  /**
   * Generate TypeScript type definitions
   */
  generateTypeDefinitions(tokens) {
    const types = [];
    
    types.push('// Design Tokens - Auto-generated TypeScript Definitions');
    types.push('// Do not edit this file manually');
    types.push('');

    // Generate interfaces for each token category
    if (tokens.colors) {
      types.push('export interface Colors {');
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          types.push(`  ${category}: {`);
          Object.keys(shades).forEach(shade => {
            types.push(`    "${shade}": string;`);
          });
          types.push('  };');
        }
      });
      types.push('}');
      types.push('');
    }

    if (tokens.spacing) {
      types.push('export interface Spacing {');
      Object.keys(tokens.spacing).forEach(key => {
        types.push(`  "${key}": string;`);
      });
      types.push('}');
      types.push('');
    }

    if (tokens.typography) {
      types.push('export interface Typography {');
      Object.entries(tokens.typography).forEach(([category, values]) => {
        if (values && typeof values === 'object') {
          types.push(`  ${category}: {`);
          Object.keys(values).forEach(key => {
            types.push(`    "${key}": string;`);
          });
          types.push('  };');
        }
      });
      types.push('}');
      types.push('');
    }

    // Main design tokens interface
    types.push('export interface DesignTokens {');
    if (tokens.colors) types.push('  colors: Colors;');
    if (tokens.spacing) types.push('  spacing: Spacing;');
    if (tokens.typography) types.push('  typography: Typography;');
    if (tokens.borderRadius) types.push('  borderRadius: Record<string, string>;');
    if (tokens.shadows) types.push('  shadows: Record<string, string>;');
    if (tokens.opacity) types.push('  opacity: Record<string, string>;');
    if (tokens.zIndex) types.push('  zIndex: Record<string, number>;');
    if (tokens.transitions) {
      types.push('  transitions: {');
      types.push('    duration: Record<string, string>;');
      types.push('    easing: Record<string, string>;');
      types.push('  };');
    }
    if (tokens.breakpoints) types.push('  breakpoints: Record<string, string>;');
    types.push('  source: string;');
    types.push('  lastLoaded: string;');
    types.push('}');
    types.push('');

    // Export token constants
    types.push('// Token value constants');
    types.push('declare const tokens: DesignTokens;');
    types.push('export default tokens;');

    return types.join('\n');
  }

  /**
   * Generate SCSS variables
   */
  async generateSCSS(tokens, outputPath) {
    const scss = this.generateSCSSVariables(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, scss);
    
    console.log(`✅ Generated SCSS: ${outputPath}`);
    return { path: outputPath, content: scss };
  }

  /**
   * Generate SCSS variables string
   */
  generateSCSSVariables(tokens) {
    const scss = [];
    
    scss.push('// Design Tokens - Auto-generated SCSS Variables');
    scss.push('// Do not edit this file manually');
    scss.push('');

    // Colors
    if (tokens.colors) {
      scss.push('// Colors');
      Object.entries(tokens.colors).forEach(([category, shades]) => {
        if (shades && typeof shades === 'object') {
          Object.entries(shades).forEach(([shade, value]) => {
            scss.push(`$color-${category}-${shade}: ${value};`);
          });
        }
      });
      scss.push('');
    }

    // Spacing
    if (tokens.spacing) {
      scss.push('// Spacing');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        scss.push(`$spacing-${key}: ${value};`);
      });
      scss.push('');
    }

    // Typography
    if (tokens.typography) {
      scss.push('// Typography');
      Object.entries(tokens.typography).forEach(([category, values]) => {
        if (values && typeof values === 'object') {
          Object.entries(values).forEach(([key, value]) => {
            scss.push(`$typography-${category}-${key}: ${value};`);
          });
        }
      });
      scss.push('');
    }

    // Other categories
    ['borderRadius', 'shadows', 'opacity', 'zIndex'].forEach(category => {
      if (tokens[category]) {
        scss.push(`// ${category.charAt(0).toUpperCase() + category.slice(1)}`);
        Object.entries(tokens[category]).forEach(([key, value]) => {
          const variableName = this.kebabCase(category);
          scss.push(`$${variableName}-${key}: ${value};`);
        });
        scss.push('');
      }
    });

    // Transitions
    if (tokens.transitions) {
      scss.push('// Transitions');
      if (tokens.transitions.duration) {
        Object.entries(tokens.transitions.duration).forEach(([key, value]) => {
          scss.push(`$transition-duration-${key}: ${value};`);
        });
      }
      if (tokens.transitions.easing) {
        Object.entries(tokens.transitions.easing).forEach(([key, value]) => {
          scss.push(`$transition-easing-${key}: ${value};`);
        });
      }
      scss.push('');
    }

    // Breakpoints
    if (tokens.breakpoints) {
      scss.push('// Breakpoints');
      Object.entries(tokens.breakpoints).forEach(([key, value]) => {
        scss.push(`$breakpoint-${key}: ${value};`);
      });
      scss.push('');
    }

    return scss.join('\n');
  }

  /**
   * Generate platform-specific formats
   */
  async generateIOS(tokens, outputPath) {
    // iOS color definitions
    const swift = this.generateSwiftColors(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, swift);
    
    console.log(`✅ Generated iOS Swift: ${outputPath}`);
    return { path: outputPath, content: swift };
  }

  async generateAndroid(tokens, outputPath) {
    // Android XML resources
    const xml = this.generateAndroidXML(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, xml);
    
    console.log(`✅ Generated Android XML: ${outputPath}`);
    return { path: outputPath, content: xml };
  }

  async generateXamarin(tokens, outputPath) {
    // Xamarin XAML resource dictionary
    const xaml = this.generateXamarinXAML(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, xaml);
    
    console.log(`✅ Generated Xamarin XAML: ${outputPath}`);
    return { path: outputPath, content: xaml };
  }

  async generateReactNative(tokens, outputPath) {
    // React Native compatible JavaScript/TypeScript
    const content = this.generateReactNativeContent(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    
    console.log(`✅ Generated React Native: ${outputPath}`);
    return { path: outputPath, content };
  }

  async generateFlutter(tokens, outputPath) {
    // Flutter/Dart class
    const content = this.generateFlutterContent(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    
    console.log(`✅ Generated Flutter/Dart: ${outputPath}`);
    return { path: outputPath, content };
  }

  async generateKotlinCompose(tokens, outputPath) {
    // Kotlin Compose class
    const content = this.generateKotlinComposeContent(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    
    console.log(`✅ Generated Kotlin Compose: ${outputPath}`);
    return { path: outputPath, content };
  }

  async generateSwiftUI(tokens, outputPath) {
    // SwiftUI class
    const content = this.generateSwiftUIContent(tokens);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, content);
    
    console.log(`✅ Generated SwiftUI: ${outputPath}`);
    return { path: outputPath, content };
  }

  /**
   * Utility methods
   */
  
  /**
   * Get token value from either Token Studio format or direct value
   */
  getTokenValue(tokenData) {
    if (tokenData && typeof tokenData === 'object') {
      // Token Studio format: {value: "...", type: "..."}
      return tokenData.value || tokenData.$value;
    }
    // Direct value
    return tokenData;
  }

  kebabCase(str) {
    return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
  }

  toCamelCase(str) {
    return str
      .replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
      .replace(/^./, c => c.toLowerCase());
  }

  toPascalCase(str) {
    return str
      .replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
      .replace(/^./, c => c.toUpperCase());
  }

  convertToPoints(cssValue) {
    if (typeof cssValue !== 'string') return '0';
    
    // Remove any whitespace
    const value = cssValue.trim();
    
    // Handle numeric values (assume px)
    if (/^\d+\.?\d*$/.test(value)) {
      return value;
    }
    
    // Convert common CSS units to points
    const match = value.match(/^([\d.]+)(px|rem|em|pt)$/);
    if (match) {
      const [, num, unit] = match;
      const numValue = parseFloat(num);
      
      switch (unit) {
        case 'px':
          return numValue.toString();
        case 'rem':
          return (numValue * 16).toString(); // Assuming 1rem = 16px
        case 'em':
          return (numValue * 16).toString(); // Assuming 1em = 16px
        case 'pt':
          return numValue.toString();
        default:
          return numValue.toString();
      }
    }
    
    return '0';
  }

  parseCSShadow(shadowValue) {
    // Parse CSS box-shadow value
    // Format: offset-x offset-y blur-radius color
    // Example: "0 2px 4px rgba(0, 0, 0, 0.1)"
    const parts = shadowValue.trim().split(/\s+/);
    
    let x = '0', y = '0', blur = '0', color = '#000000';
    
    if (parts.length >= 2) {
      x = this.convertToPoints(parts[0]);
      y = this.convertToPoints(parts[1]);
    }
    
    if (parts.length >= 3) {
      blur = this.convertToPoints(parts[2]);
    }
    
    if (parts.length >= 4) {
      // Find color part (might have spaces for rgba)
      const colorPart = parts.slice(3).join(' ');
      if (colorPart.startsWith('#')) {
        color = colorPart;
      } else if (colorPart.includes('rgba')) {
        // Convert rgba to hex (simplified)
        color = '#000000'; // Fallback
      }
    }
    
    return { x, y, blur, color };
  }

  convertToDp(cssValue) {
    if (typeof cssValue !== 'string') return '0dp';
    
    const value = cssValue.trim();
    
    // Handle numeric values (assume px)
    if (/^\d+\.?\d*$/.test(value)) {
      return `${value}dp`;
    }
    
    // Convert common CSS units to dp
    const match = value.match(/^([\d.]+)(px|rem|em|dp)$/);
    if (match) {
      const [, num, unit] = match;
      const numValue = parseFloat(num);
      
      switch (unit) {
        case 'px':
          return `${numValue}dp`;
        case 'rem':
          return `${numValue * 16}dp`; // Assuming 1rem = 16px
        case 'em':
          return `${numValue * 16}dp`; // Assuming 1em = 16px
        case 'dp':
          return `${numValue}dp`;
        default:
          return `${numValue}dp`;
      }
    }
    
    return '0dp';
  }

  convertToSp(cssValue) {
    if (typeof cssValue !== 'string') return '0sp';
    
    const value = cssValue.trim();
    
    // Handle numeric values (assume px)
    if (/^\d+\.?\d*$/.test(value)) {
      return `${value}sp`;
    }
    
    // Convert common CSS units to sp (for text sizes)
    const match = value.match(/^([\d.]+)(px|rem|em|sp)$/);
    if (match) {
      const [, num, unit] = match;
      const numValue = parseFloat(num);
      
      switch (unit) {
        case 'px':
          return `${numValue}sp`;
        case 'rem':
          return `${numValue * 16}sp`; // Assuming 1rem = 16px
        case 'em':
          return `${numValue * 16}sp`; // Assuming 1em = 16px
        case 'sp':
          return `${numValue}sp`;
        default:
          return `${numValue}sp`;
      }
    }
    
    return '0sp';
  }

  convertToRNPoints(cssValue) {
    if (typeof cssValue !== 'string') return 0;
    
    const value = cssValue.trim();
    
    // Handle numeric values (assume px)
    if (/^\d+\.?\d*$/.test(value)) {
      return parseFloat(value);
    }
    
    // Convert common CSS units to React Native points
    const match = value.match(/^([\d.]+)(px|rem|em)$/);
    if (match) {
      const [, num, unit] = match;
      const numValue = parseFloat(num);
      
      switch (unit) {
        case 'px':
          return numValue;
        case 'rem':
          return numValue * 16; // Assuming 1rem = 16px
        case 'em':
          return numValue * 16; // Assuming 1em = 16px
        default:
          return numValue;
      }
    }
    
    return 0;
  }

  convertToRNShadow(cssValue) {
    // Convert CSS box-shadow to React Native shadow style
    const shadowProps = this.parseCSShadow(cssValue);
    
    return {
      shadowOffset: {
        width: parseFloat(shadowProps.x),
        height: parseFloat(shadowProps.y)
      },
      shadowRadius: parseFloat(shadowProps.blur),
      shadowColor: shadowProps.color,
      shadowOpacity: 1,
      // Also add elevation for Android
      elevation: Math.max(2, parseFloat(shadowProps.blur) / 2)
    };
  }

  convertToFlutterColor(hexColor) {
    // Convert hex color to Flutter Color format
    if (!hexColor.startsWith('#')) return 'Colors.black';
    
    const hex = hexColor.replace('#', '');
    if (hex.length === 6) {
      return `Color(0xFF${hex.toUpperCase()})`;
    } else if (hex.length === 3) {
      // Expand 3-digit hex to 6-digit
      const expanded = hex.split('').map(c => c + c).join('');
      return `Color(0xFF${expanded.toUpperCase()})`;
    }
    
    return 'Colors.black';
  }

  generateSwiftColors(tokens) {
    const swift = [];
    swift.push('// Design Tokens - Auto-generated Swift');
    swift.push('// Do not edit this file manually');
    swift.push('import UIKit');
    swift.push('');
    
    // Colors
    if (tokens.colors) {
      swift.push('extension UIColor {');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          // Nested structure: category -> shade -> value
          Object.entries(value).forEach(([shade, colorValue]) => {
            // Handle both simple string values and Figma Token Studio format
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              const varName = this.toCamelCase(`${key} ${shade}`);
              swift.push(`    static let ${varName} = UIColor(hex: "${actualValue}")`);
            }
          });
        } else {
          // Handle flat structure
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const varName = this.toCamelCase(key);
            swift.push(`    static let ${varName} = UIColor(hex: "${actualValue}")`);
          }
        }
      });
      swift.push('}');
      swift.push('');
    }
    
    // Spacing
    if (tokens.spacing) {
      swift.push('struct Spacing {');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          swift.push(`    static let ${this.toCamelCase(key)}: CGFloat = ${numericValue}`);
        }
      });
      swift.push('}');
      swift.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        swift.push('struct FontSize {');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToPoints(actualValue);
            swift.push(`    static let ${this.toCamelCase(key)}: CGFloat = ${numericValue}`);
          }
        });
        swift.push('}');
        swift.push('');
      }
      
      if (tokens.typography.fontFamily) {
        swift.push('struct FontFamily {');
        Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            // Extract first font from font stack for iOS
            const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
            swift.push(`    static let ${this.toCamelCase(key)} = "${fontName}"`);
          }
        });
        swift.push('}');
        swift.push('');
      }
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      swift.push('struct BorderRadius {');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          swift.push(`    static let ${this.toCamelCase(key)}: CGFloat = ${numericValue}`);
        }
      });
      swift.push('}');
      swift.push('');
    }
    
    // Shadows
    if (tokens.shadows) {
      swift.push('struct Shadow {');
      Object.entries(tokens.shadows).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          // Parse CSS shadow into iOS shadow properties
          const shadowProps = this.parseCSShadow(actualValue);
          swift.push(`    static let ${this.toCamelCase(key)} = ShadowStyle(`);
          swift.push(`        offset: CGSize(width: ${shadowProps.x}, height: ${shadowProps.y}),`);
          swift.push(`        blur: ${shadowProps.blur},`);
          swift.push(`        color: UIColor(hex: "${shadowProps.color}")`);
          swift.push(`    )`);
        }
      });
      swift.push('}');
      swift.push('');
      
      // Add shadow style struct
      swift.push('struct ShadowStyle {');
      swift.push('    let offset: CGSize');
      swift.push('    let blur: CGFloat');
      swift.push('    let color: UIColor');
      swift.push('}');
      swift.push('');
    }
    
    swift.push('// UIColor hex initializer extension');
    swift.push('extension UIColor {');
    swift.push('    convenience init(hex: String) {');
    swift.push('        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)');
    swift.push('        var int: UInt64 = 0');
    swift.push('        Scanner(string: hex).scanHexInt64(&int)');
    swift.push('        let a, r, g, b: UInt64');
    swift.push('        switch hex.count {');
    swift.push('        case 3: // RGB (12-bit)');
    swift.push('            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)');
    swift.push('        case 6: // RGB (24-bit)');
    swift.push('            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)');
    swift.push('        case 8: // ARGB (32-bit)');
    swift.push('            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)');
    swift.push('        default:');
    swift.push('            (a, r, g, b) = (1, 1, 1, 0)');
    swift.push('        }');
    swift.push('        self.init(');
    swift.push('            red: Double(r) / 255,');
    swift.push('            green: Double(g) / 255,');
    swift.push('            blue: Double(b) / 255,');
    swift.push('            alpha: Double(a) / 255');
    swift.push('        )');
    swift.push('    }');
    swift.push('}');
    return swift.join('\n');
  }

  generateAndroidXML(tokens) {
    const xml = [];
    xml.push('<?xml version="1.0" encoding="utf-8"?>');
    xml.push('<!-- Design Tokens - Auto-generated Android Resources -->');
    xml.push('<!-- Do not edit this file manually -->');
    xml.push('<resources>');
    xml.push('');
    
    // Colors
    if (tokens.colors) {
      xml.push('    <!-- Colors -->');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          // Nested structure: category -> shade -> value
          Object.entries(value).forEach(([shade, colorValue]) => {
            // Handle both simple string values and Figma Token Studio format
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              xml.push(`    <color name="${key}_${shade}">${actualValue}</color>`);
            }
          });
        } else {
          // Handle flat structure
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const colorName = key.replace(/-/g, '_');
            xml.push(`    <color name="${colorName}">${actualValue}</color>`);
          }
        }
      });
      xml.push('');
    }
    
    // Dimensions (spacing, border radius, font sizes)
    const dimensionTokens = [];
    
    if (tokens.spacing) {
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const dpValue = this.convertToDp(actualValue);
          dimensionTokens.push(`    <dimen name="spacing_${key}">${dpValue}</dimen>`);
        }
      });
    }
    
    if (tokens.borderRadius) {
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const dpValue = this.convertToDp(actualValue);
          dimensionTokens.push(`    <dimen name="border_radius_${key}">${dpValue}</dimen>`);
        }
      });
    }
    
    if (tokens.typography?.fontSize) {
      Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const spValue = this.convertToSp(actualValue);
          dimensionTokens.push(`    <dimen name="font_size_${key}">${spValue}</dimen>`);
        }
      });
    }
    
    if (dimensionTokens.length > 0) {
      xml.push('    <!-- Dimensions -->');
      xml.push(...dimensionTokens);
      xml.push('');
    }
    
    // Strings (font families)
    if (tokens.typography?.fontFamily) {
      xml.push('    <!-- Font Families -->');
      Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          // Extract first font from font stack for Android
          const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
          xml.push(`    <string name="font_family_${key}">${fontName}</string>`);
        }
      });
      xml.push('');
    }
    
    xml.push('</resources>');
    return xml.join('\n');
  }

  generateXamarinXAML(tokens) {
    const xaml = [];
    xaml.push('<?xml version="1.0" encoding="utf-8"?>');
    xaml.push('<!-- Design Tokens - Auto-generated Xamarin XAML Resources -->');
    xaml.push('<!-- Do not edit this file manually -->');
    xaml.push('<ResourceDictionary xmlns="http://xamarin.com/schemas/2014/forms"');
    xaml.push('                    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">');
    xaml.push('');
    
    // Colors
    if (tokens.colors) {
      xaml.push('    <!-- Colors -->');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          // Nested structure: category -> shade -> value
          Object.entries(value).forEach(([shade, colorValue]) => {
            // Handle both simple string values and Figma Token Studio format
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              const colorName = this.toPascalCase(`${key} ${shade}`);
              xaml.push(`    <Color x:Key="${colorName}">${actualValue}</Color>`);
            }
          });
        } else {
          // Handle flat structure
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const colorName = this.toPascalCase(key);
            xaml.push(`    <Color x:Key="${colorName}">${actualValue}</Color>`);
          }
        }
      });
      xaml.push('');
    }
    
    // Spacing/Dimensions
    if (tokens.spacing) {
      xaml.push('    <!-- Spacing -->');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          const spacingName = this.toPascalCase(`Spacing ${key}`);
          xaml.push(`    <x:Double x:Key="${spacingName}">${numericValue}</x:Double>`);
        }
      });
      xaml.push('');
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      xaml.push('    <!-- Border Radius -->');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToPoints(actualValue);
          const radiusName = this.toPascalCase(`BorderRadius ${key}`);
          xaml.push(`    <x:Double x:Key="${radiusName}">${numericValue}</x:Double>`);
        }
      });
      xaml.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        xaml.push('    <!-- Font Sizes -->');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToPoints(actualValue);
            const fontSizeName = this.toPascalCase(`FontSize ${key}`);
            xaml.push(`    <x:Double x:Key="${fontSizeName}">${numericValue}</x:Double>`);
          }
        });
        xaml.push('');
      }
      
      if (tokens.typography.fontFamily) {
        xaml.push('    <!-- Font Families -->');
        Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            // Extract first font from font stack for Xamarin
            const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
            const fontFamilyName = this.toPascalCase(`FontFamily ${key}`);
            xaml.push(`    <x:String x:Key="${fontFamilyName}">${fontName}</x:String>`);
          }
        });
        xaml.push('');
      }
    }
    
    xaml.push('</ResourceDictionary>');
    return xaml.join('\n');
  }

  generateReactNativeContent(tokens) {
    const js = [];
    
    js.push('// Design Tokens - Auto-generated React Native Styles');
    js.push('// Do not edit this file manually');
    js.push('');
    
    // Colors
    if (tokens.colors) {
      js.push('export const colors = {');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          js.push(`  ${this.toCamelCase(key)}: {`);
          Object.entries(value).forEach(([shade, colorValue]) => {
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              js.push(`    ${this.toCamelCase(shade)}: '${actualValue}',`);
            }
          });
          js.push('  },');
        } else {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            js.push(`  ${this.toCamelCase(key)}: '${actualValue}',`);
          }
        }
      });
      js.push('};');
      js.push('');
    }
    
    // Spacing
    if (tokens.spacing) {
      js.push('export const spacing = {');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          js.push(`  ${this.toCamelCase(key)}: ${numericValue},`);
        }
      });
      js.push('};');
      js.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        js.push('export const fontSize = {');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToRNPoints(actualValue);
            js.push(`  ${this.toCamelCase(key)}: ${numericValue},`);
          }
        });
        js.push('};');
        js.push('');
      }
      
      if (tokens.typography.fontFamily) {
        js.push('export const fontFamily = {');
        Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            // Extract first font from font stack for React Native
            const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
            js.push(`  ${this.toCamelCase(key)}: '${fontName}',`);
          }
        });
        js.push('};');
        js.push('');
      }
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      js.push('export const borderRadius = {');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          js.push(`  ${this.toCamelCase(key)}: ${numericValue},`);
        }
      });
      js.push('};');
      js.push('');
    }
    
    // Shadows for React Native
    if (tokens.shadows) {
      js.push('export const shadows = {');
      Object.entries(tokens.shadows).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const shadowStyle = this.convertToRNShadow(actualValue);
          js.push(`  ${this.toCamelCase(key)}: ${JSON.stringify(shadowStyle, null, 4).replace(/\n/g, '\n    ')},`);
        }
      });
      js.push('};');
      js.push('');
    }
    
    // Combined export
    js.push('export const tokens = {');
    if (tokens.colors) js.push('  colors,');
    if (tokens.spacing) js.push('  spacing,');
    if (tokens.typography?.fontSize) js.push('  fontSize,');
    if (tokens.typography?.fontFamily) js.push('  fontFamily,');
    if (tokens.borderRadius) js.push('  borderRadius,');
    if (tokens.shadows) js.push('  shadows,');
    js.push('};');
    js.push('');
    js.push('export default tokens;');
    
    return js.join('\n');
  }

  generateFlutterContent(tokens) {
    const dart = [];
    
    dart.push('// Design Tokens - Auto-generated Flutter/Dart');
    dart.push('// Do not edit this file manually');
    dart.push('');
    dart.push('import \'package:flutter/material.dart\';');
    dart.push('');
    dart.push('class DesignTokens {');
    
    // Colors
    if (tokens.colors) {
      dart.push('  // Colors');
      dart.push('  static class Colors {');
      Object.entries(tokens.colors).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          Object.entries(value).forEach(([shade, colorValue]) => {
            const actualValue = this.getTokenValue(colorValue);
            if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
              const colorName = this.toCamelCase(`${key}_${shade}`);
              const flutterColor = this.convertToFlutterColor(actualValue);
              dart.push(`    static const Color ${colorName} = ${flutterColor};`);
            }
          });
        } else {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string' && actualValue.startsWith('#')) {
            const colorName = this.toCamelCase(key);
            const flutterColor = this.convertToFlutterColor(actualValue);
            dart.push(`    static const Color ${colorName} = ${flutterColor};`);
          }
        }
      });
      dart.push('  }');
      dart.push('');
    }
    
    // Spacing
    if (tokens.spacing) {
      dart.push('  // Spacing');
      dart.push('  static class Spacing {');
      Object.entries(tokens.spacing).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          dart.push(`    static const double ${this.toCamelCase(key)} = ${numericValue};`);
        }
      });
      dart.push('  }');
      dart.push('');
    }
    
    // Typography
    if (tokens.typography) {
      if (tokens.typography.fontSize) {
        dart.push('  // Font Sizes');
        dart.push('  static class FontSize {');
        Object.entries(tokens.typography.fontSize).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const numericValue = this.convertToRNPoints(actualValue);
            dart.push(`    static const double ${this.toCamelCase(key)} = ${numericValue};`);
          }
        });
        dart.push('  }');
        dart.push('');
      }
      
      if (tokens.typography.fontFamily) {
        dart.push('  // Font Families');
        dart.push('  static class FontFamily {');
        Object.entries(tokens.typography.fontFamily).forEach(([key, value]) => {
          const actualValue = this.getTokenValue(value);
          if (typeof actualValue === 'string') {
            const fontName = actualValue.split(',')[0].trim().replace(/['"]/g, '');
            dart.push(`    static const String ${this.toCamelCase(key)} = '${fontName}';`);
          }
        });
        dart.push('  }');
        dart.push('');
      }
    }
    
    // Border Radius
    if (tokens.borderRadius) {
      dart.push('  // Border Radius');
      dart.push('  static class BorderRadius {');
      Object.entries(tokens.borderRadius).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const numericValue = this.convertToRNPoints(actualValue);
          dart.push(`    static const double ${this.toCamelCase(key)} = ${numericValue};`);
        }
      });
      dart.push('  }');
      dart.push('');
    }
    
    // Shadows
    if (tokens.shadows) {
      dart.push('  // Shadows');
      dart.push('  static class Shadows {');
      Object.entries(tokens.shadows).forEach(([key, value]) => {
        const actualValue = this.getTokenValue(value);
        if (typeof actualValue === 'string') {
          const shadowProps = this.parseCSShadow(actualValue);
          const flutterColor = this.convertToFlutterColor(shadowProps.color);
          dart.push(`    static const BoxShadow ${this.toCamelCase(key)} = BoxShadow(`);
          dart.push(`      offset: Offset(${shadowProps.x}, ${shadowProps.y}),`);
          dart.push(`      blurRadius: ${shadowProps.blur},`);
          dart.push(`      color: ${flutterColor},`);
          dart.push('    );');
        }
      });
      dart.push('  }');
      dart.push('');
    }
    
    dart.push('}');
    
    return dart.join('\n');
  }

  /**
   * Generate JSON output
   */
  async generateJSON(tokens, outputPath) {
    const jsonContent = this.generateJSONContent(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, jsonContent);
    
    console.log(`✅ Generated JSON: ${outputPath}`);
    return { path: outputPath, content: jsonContent };
  }

  generateJSONContent(tokens) {
    // Create a clean JSON output with metadata
    const output = {
      $schema: 'https://schemas.figma.com/figma-tokens/1.0.0',
      $metadata: {
        generatedBy: 'design-tokens-sync',
        generatedAt: new Date().toISOString(),
        version: '1.0.0'
      },
      ...tokens
    };

    // Remove internal metadata
    delete output.source;
    delete output.lastLoaded;

    return JSON.stringify(output, null, 2);
  }

  /**
   * Generate JavaScript/ES module output
   */
  async generateJavaScript(tokens, outputPath) {
    const jsContent = this.generateJavaScriptContent(tokens);
    
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, jsContent);
    
    console.log(`✅ Generated JavaScript: ${outputPath}`);
    return { path: outputPath, content: jsContent };
  }

  generateJavaScriptContent(tokens) {
    const js = [];
    
    js.push('// Design Tokens - Auto-generated JavaScript/ES Module');
    js.push('// Do not edit this file manually');
    js.push('');

    // Create clean tokens object without internal metadata
    const cleanTokens = { ...tokens };
    delete cleanTokens.source;
    delete cleanTokens.lastLoaded;

    js.push('// Design tokens as JavaScript object');
    js.push(`export const tokens = ${JSON.stringify(cleanTokens, null, 2)};`);
    js.push('');

    // Add individual exports for each category
    if (cleanTokens.colors) {
      js.push('// Individual category exports');
      js.push(`export const colors = ${JSON.stringify(cleanTokens.colors, null, 2)};`);
    }

    if (cleanTokens.spacing) {
      js.push(`export const spacing = ${JSON.stringify(cleanTokens.spacing, null, 2)};`);
    }

    if (cleanTokens.typography) {
      js.push(`export const typography = ${JSON.stringify(cleanTokens.typography, null, 2)};`);
    }

    if (cleanTokens.borderRadius) {
      js.push(`export const borderRadius = ${JSON.stringify(cleanTokens.borderRadius, null, 2)};`);
    }

    if (cleanTokens.shadows) {
      js.push(`export const shadows = ${JSON.stringify(cleanTokens.shadows, null, 2)};`);
    }

    if (cleanTokens.opacity) {
      js.push(`export const opacity = ${JSON.stringify(cleanTokens.opacity, null, 2)};`);
    }

    js.push('');
    js.push('// Default export');
    js.push('export default tokens;');

    return js.join('\n');
  }
} 